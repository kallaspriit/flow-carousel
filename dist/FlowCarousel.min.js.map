{"version":3,"file":"FlowCarousel.min.js","sources":["../node_modules/grunt-requirejs/node_modules/almond/almond.js","jquery.js","Deferred.js","AbstractNavigator.js","Util.js","KeyboardNavigator.js","DragNavigator.js","SlideshowNavigator.js","InterfaceNavigator.js","Config.js","AbstractDataSource.js","ArrayDataSource.js","HtmlDataSource.js","AbstractAnimator.js","DefaultAnimator.js","AbstractRenderer.js","HtmlRenderer.js","EventEmitter.js","Exporter.js","FlowCarousel.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n\n","define('jquery',[\r\n\t'jquery'\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Provides a way to include jquery without actually including it in the build.\r\n\t *\r\n\t * Expects that jQuery is already loaded.\r\n\t */\r\n\treturn window.jQuery;\r\n});\n","define('Deferred',[\r\n\t'jquery'\r\n], function($) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Provides utility functionality.\r\n\t *\r\n\t * Uses the jQuery deferred implementation.\r\n\t *\r\n\t * @class Deferred\r\n\t * @constructor\r\n\t */\r\n\tvar Deferred = $.Deferred;\r\n\r\n\t// proxy to jQuery when()\r\n\tDeferred.when = $.when;\r\n\r\n\treturn Deferred;\r\n});\n","define('AbstractNavigator',[\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Abstract navigator base class.\r\n\t *\r\n\t * Use navigators to navigate the carousel using mouse, touch, keyboard, ui, urls etc.\r\n\t *\r\n\t * @class AbstractNavigator\r\n\t * @constructor\r\n\t */\r\n\tfunction AbstractNavigator() {\r\n\t\tthis._carousel = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Initiated the navigator.\r\n\t *\r\n\t * This is called automatically by the carousel and calls _setup() in turn that the subclasses should implement.\r\n\t *\r\n\t * @method init\r\n\t * @param {FlowCarousel} carousel The carousel component\r\n\t */\r\n\tAbstractNavigator.prototype.init = function(carousel) {\r\n\t\tthis._carousel = carousel;\r\n\r\n\t\tthis._setup();\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tAbstractNavigator.prototype.destroy = function() {\r\n\t\t// do nothing by default\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the init to set up the navigator.\r\n\t *\r\n\t * @method _setup\r\n\t * @protected\r\n\t */\r\n\tAbstractNavigator.prototype._setup = function() {\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\treturn AbstractNavigator;\r\n});\n","define('Util',[\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Provides utility functionality.\r\n\t *\r\n\t * @class Util\r\n\t * @constructor\r\n\t */\r\n\treturn {\r\n\r\n\t\t/**\r\n\t\t * Returns whether given arguments is an object (and not an array nor null).\r\n\t\t *\r\n\t\t * @method isObject\r\n\t\t * @param {*} arg Arguments to check\r\n\t\t * @return {boolean}\r\n\t\t * @static\r\n\t\t */\r\n\t\tisObject: function(arg) {\r\n\t\t\treturn typeof arg === 'object' && arg !== null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns whether given arguments is an array (and not a object nor null).\r\n\t\t *\r\n\t\t * @method isArray\r\n\t\t * @param {*} arg Arguments to check\r\n\t\t * @return {boolean}\r\n\t\t * @static\r\n\t\t */\r\n\t\tisArray: function(arg) {\r\n\t\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns whether given object contains given value.\r\n\t\t *\r\n\t\t * @method objectHasValue\r\n\t\t * @param {object} obj Object to check\r\n\t\t * @param {*} value Value to search for\r\n\t\t * @return {boolean}\r\n\t\t */\r\n\t\tobjectHasValue: function(obj, value) {\r\n\t\t\tvar prop;\r\n\r\n\t\t\tfor (prop in obj) {\r\n\t\t\t\tif(obj.hasOwnProperty(prop) && obj[prop] === value) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses a css transform matrix.\r\n\t\t *\r\n\t\t * Input is something along the way of \"matrix(1, 0, 0, 1, -1877, 0)\" or a 3D matrix like\r\n\t\t * \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -100, 0, 0, 1)\"\r\n\t\t *\r\n\t\t * Returns objects with keys x, y.\r\n\t\t *\r\n\t\t * @method parseTransformMatrix\r\n\t\t * @param {string} matrix Matrix to parse\r\n\t\t * @return {object}\r\n\t\t */\r\n\t\tparseTransformMatrix: function(matrix) {\r\n\t\t\tvar offset,\r\n\t\t\t\titemIndexes,\r\n\t\t\t\ttrimmed,\r\n\t\t\t\tnoWhitespace,\r\n\t\t\t\titems,\r\n\t\t\t\tresult;\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\t/*if (matrix === 'none') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: 0,\r\n\t\t\t\t\ty: 0\r\n\t\t\t\t};\r\n\t\t\t}*/\r\n\r\n\t\t\t// TODO remove the istanbul ignore once karma coverage fixes not counting these lines\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tif (matrix.substring(0, 8) === 'matrix3d') { // IE uses matrix3d\r\n\t\t\t\toffset = 9;\r\n\t\t\t\titemIndexes = [12, 13];\r\n\t\t\t} else if (matrix.substring(0, 6) === 'matrix') { // webkit, safari, opera\r\n\t\t\t\toffset = 7;\r\n\t\t\t\titemIndexes = [4, 5];\r\n\t\t\t} else if (matrix.substring(0, 11) === 'translate3d') { // Safari uses translate3d sometimes\r\n\t\t\t\toffset = 12;\r\n\t\t\t\titemIndexes = [0, 1];\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Unsupported matrix format \"' + matrix + '\"');\r\n\t\t\t}\r\n\r\n\t\t\ttrimmed = matrix.substr(offset).substr(0, matrix.length - offset - 1);\r\n\t\t\tnoWhitespace = trimmed.replace(/ +/g, '');\r\n\t\t\titems = noWhitespace.split(/,/);\r\n\r\n\t\t\tresult = {\r\n\t\t\t\tx: parseInt(items[itemIndexes[0]], 10),\r\n\t\t\t\ty: parseInt(items[itemIndexes[1]], 10)\r\n\t\t\t};\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes CSS classes from current element that have the given prefix.\r\n\t\t *\r\n\t\t * @method removeElementClassesPrefixedWith\r\n\t\t * @param {DOMElement} element Element to modify\r\n\t\t * @param {string} cssPrefix The CSS prefix\r\n\t\t */\r\n\t\tremoveElementClassesPrefixedWith: function(element, cssPrefix) {\r\n\t\t\tvar wrapClasses = $(element).prop('class').split(' '),\r\n\t\t\t\tfilteredClasses = [],\r\n\t\t\t\ti;\r\n\r\n\t\t\tfor (i = 0; i < wrapClasses.length; i++) {\r\n\t\t\t\tif (wrapClasses[i].substr(0, cssPrefix.length) !== cssPrefix) {\r\n\t\t\t\t\tfilteredClasses.push(wrapClasses[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$(element).prop('class', filteredClasses.join(' '));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns a clone of given object.\r\n\t\t *\r\n\t\t * @param {object} obj Object to clone\r\n\t\t * @return {object}\r\n\t\t */\r\n\t\tcloneObj: function(obj) {\r\n\t\t\treturn JSON.parse(JSON.stringify(obj));\r\n\t\t}\r\n\t};\r\n});\n","define('KeyboardNavigator',[\r\n\t'AbstractNavigator',\r\n\t'Util'\r\n], function(AbstractNavigator, Util) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Keyboard navigator.\r\n\t *\r\n\t * @class KeyboardNavigator\r\n\t * @extends AbstractNavigator\r\n\t * @param {object} config Navigator configuration\r\n\t * @constructor\r\n\t */\r\n\tfunction KeyboardNavigator(config) {\r\n\t\tAbstractNavigator.call(this);\r\n\r\n\t\tthis._config = config;\r\n\t\tthis._mode = null;\r\n\t\tthis._mouseEntered = false;\r\n\r\n\t\tthis._eventListeners = {\r\n\t\t\tmouseenter: this._onRawMouseEnter.bind(this),\r\n\t\t\tmouseleave: this._onRawMouseLeave.bind(this),\r\n\t\t\tkeydown: this._onRawKeyDown.bind(this),\r\n\t\t};\r\n\r\n\t\tthis.setMode(config.mode || KeyboardNavigator.Mode.NAVIGATE_PAGE);\r\n\t}\r\n\r\n\tKeyboardNavigator.prototype = Object.create(AbstractNavigator.prototype);\r\n\r\n\t/**\r\n\t * List of supported navigation modes.\r\n\t *\r\n\t * @property Mode\r\n\t * @type {object}\r\n\t * @param {string} Mode.NAVIGATE_PAGE='navigate-page' The navigation keys navigate one page at a time\r\n\t * @param {string} Mode.NAVIGATE_ITEM='navigate-item' The navigation keys navigate one item at a time\r\n\t */\r\n\tKeyboardNavigator.Mode = {\r\n\t\tNAVIGATE_PAGE: 'navigate-page',\r\n\t\tNAVIGATE_ITEM: 'navigate-item'\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current keyboard navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"KeyboardNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"KeyboardNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that the arrow keys change\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method setMode\r\n\t * @param {KeyboardNavigator/Mode:property} mode Mode to use\r\n\t */\r\n\tKeyboardNavigator.prototype.setMode = function(mode) {\r\n\t\tif (!Util.objectHasValue(KeyboardNavigator.Mode, mode)) {\r\n\t\t\tthrow new Error('Invalid mode \"' + mode + '\" provided');\r\n\t\t}\r\n\r\n\t\tthis._mode = mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current keyboard navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"KeyboardNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"KeyboardNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that the arrow keys change\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method getMode\r\n\t * @return {KeyboardNavigator/Mode:property}\r\n\t */\r\n\tKeyboardNavigator.prototype.getMode = function() {\r\n\t\treturn this._mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the init to set up the navigator.\r\n\t *\r\n\t * @method _setup\r\n\t * @protected\r\n\t */\r\n\tKeyboardNavigator.prototype._setup = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$window = $(window);\r\n\r\n\t\t// make sure that the mouse if over the main wrap element\r\n\t\t$mainWrap\r\n\t\t\t.on('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.on('mouseleave', this._eventListeners.mouseleave);\r\n\r\n\t\t// listen for key down events\r\n\t\t$window.on('keydown', this._eventListeners.keydown);\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tKeyboardNavigator.prototype.destroy = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$window = $(window);\r\n\r\n\t\t// remove the event listeners\r\n\t\t$mainWrap\r\n\t\t\t.off('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.off('mouseleave', this._eventListeners.mouseleave);\r\n\r\n\t\t$window.off('keydown', this._eventListeners.keydown);\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseEnter\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tKeyboardNavigator.prototype._onRawMouseEnter = function(/*e*/) {\r\n\t\tthis._mouseEntered = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseLeave\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tKeyboardNavigator.prototype._onRawMouseLeave = function(/*e*/) {\r\n\t\tthis._mouseEntered = false;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on key down event.\r\n\t *\r\n\t * @method _onRawKeyDown\r\n\t * @param {Event} e Key event\r\n\t * @private\r\n\t */\r\n\tKeyboardNavigator.prototype._onRawKeyDown = function(e) {\r\n\t\tvar result = this._onKeyDown(e.keyCode);\r\n\r\n\t\tif (result === false) {\r\n\t\t\te.preventDefault();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on key down even for anywhere in the document.\r\n\t *\r\n\t * @method _onKeyDown\r\n\t * @param {number} keyCode Key press key-code.\r\n\t * @return {boolean} Should the key event be propagated further\r\n\t * @private\r\n\t */\r\n\tKeyboardNavigator.prototype._onKeyDown = function(keyCode) {\r\n\t\tvar keyCodes;\r\n\r\n\t\t// don't do anything if the mouse is not over given component\r\n\t\tif (!this._mouseEntered) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// the keycodes are based on carousel orientation (left-right arrows for horizontal and up-down for vertical)\r\n\t\tswitch (this._carousel.getOrientation()) {\r\n\t\t\tcase this._carousel.Config.Orientation.HORIZONTAL:\r\n\t\t\t\tkeyCodes = {\r\n\t\t\t\t\tprevious: 37, // arrow left\r\n\t\t\t\t\tnext: 39 // arrow right\r\n\t\t\t\t};\r\n\t\t\tbreak;\r\n\r\n\t\t\tcase this._carousel.Config.Orientation.VERTICAL:\r\n\t\t\t\tkeyCodes = {\r\n\t\t\t\t\tprevious: 38, // arrow up\r\n\t\t\t\t\tnext: 40 // arrow down\r\n\t\t\t\t};\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// navigate using the key-codes defined above\r\n\t\tswitch (keyCode) {\r\n\t\t\tcase keyCodes.next:\r\n\t\t\t\tif (this._mode === KeyboardNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\t\t\tthis._carousel.navigateToNextPage();\r\n\t\t\t\t} else if (this._mode === KeyboardNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\t\t\tthis._carousel.navigateToNextItem();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\tcase keyCodes.previous:\r\n\t\t\t\tif (this._mode === KeyboardNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\t\t\tthis._carousel.navigateToPreviousPage();\r\n\t\t\t\t} else if (this._mode === KeyboardNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\t\t\tthis._carousel.navigateToPreviousItem();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\treturn KeyboardNavigator;\r\n});\n","define('DragNavigator',[\r\n\t'AbstractNavigator',\r\n\t'Util'\r\n], function(AbstractNavigator, Util) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Drag navigator.\r\n\t *\r\n\t * @class DragNavigator\r\n\t * @extends AbstractNavigator\r\n\t * @param {object} config Navigator configuration\r\n\t * @constructor\r\n\t */\r\n\tfunction DragNavigator(config) {\r\n\t\tAbstractNavigator.call(this);\r\n\r\n\t\tthis._config = config;\r\n\t\tthis._mode = null;\r\n\t\tthis._active = false;\r\n\t\tthis._startPosition = null;\r\n\t\tthis._startOppositePosition = null;\r\n\t\tthis._startCarouselPosition = null;\r\n\t\tthis._startHoverItemIndex = null;\r\n\t\tthis._startTargetElement = null;\r\n\t\tthis._startWindowScrollTop = null;\r\n\t\tthis._lastPosition = null;\r\n\t\tthis._lastOppositePosition = null;\r\n\t\tthis._accumulatedMagnitude = {\r\n\t\t\tmain: 0,\r\n\t\t\topposite: 0\r\n\t\t};\r\n\t\tthis._eventListeners = {\r\n\t\t\tstart: this._onRawStart.bind(this),\r\n\t\t\tmove: this._onRawMove.bind(this),\r\n\t\t\tend: this._onRawEnd.bind(this),\r\n\t\t\tdragStart: this._onRawDragStart.bind(this)\r\n\t\t};\r\n\t\tthis._noActionThreshold = 15;\r\n\t\tthis._firstMoveEvent = true;\r\n\r\n\t\tthis.setMode(config.mode || DragNavigator.Mode.NAVIGATE_PAGE);\r\n\t}\r\n\r\n\tDragNavigator.prototype = Object.create(AbstractNavigator.prototype);\r\n\r\n\t/**\r\n\t * List of supported navigation modes.\r\n\t *\r\n\t * @property Mode\r\n\t * @type {object}\r\n\t * @param {string} Mode.NAVIGATE_PAGE='navigate-page' The navigation keys navigate one page at a time\r\n\t * @param {string} Mode.NAVIGATE_ITEM='navigate-item' The navigation keys navigate one item at a time\r\n\t */\r\n\tDragNavigator.Mode = {\r\n\t\tNAVIGATE_PAGE: 'navigate-page',\r\n\t\tNAVIGATE_ITEM: 'navigate-item'\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current drag navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"DragNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"DragNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that the arrow keys change\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method setMode\r\n\t * @param {DragNavigator/Mode:property} mode Mode to use\r\n\t */\r\n\tDragNavigator.prototype.setMode = function(mode) {\r\n\t\tif (!Util.objectHasValue(DragNavigator.Mode, mode)) {\r\n\t\t\tthrow new Error('Invalid mode \"' + mode + '\" provided');\r\n\t\t}\r\n\r\n\t\tthis._mode = mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current drag navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"DragNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"DragNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that the arrow keys change\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method getMode\r\n\t * @return {DragNavigator/Mode:property}\r\n\t */\r\n\tDragNavigator.prototype.getMode = function() {\r\n\t\treturn this._mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the init to set up the navigator.\r\n\t *\r\n\t * @method _setup\r\n\t * @protected\r\n\t */\r\n\tDragNavigator.prototype._setup = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$scrollerWrap = $(this._carousel.getScrollerWrap()),\r\n\t\t\t$window = $(window);\r\n\r\n\t\t// listen for mouse/touch down, move and up/leave events\r\n\t\t$scrollerWrap.on('mousedown touchstart', this._eventListeners.start);\r\n\t\t$window.on('mousemove touchmove', this._eventListeners.move);\r\n\t\t$window.on('mouseup touchend touchcancel', this._eventListeners.end);\r\n\r\n\t\t// intercept drag start event\r\n\t\t$mainWrap.on('dragstart', this._eventListeners.dragStart);\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tDragNavigator.prototype.destroy = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$scrollerWrap = $(this._carousel.getScrollerWrap()),\r\n\t\t\t$window = $(window);\r\n\r\n\t\t// listen for mouse/touch down, move and up/leave events\r\n\t\t$scrollerWrap.off('mousedown touchstart', this._eventListeners.start);\r\n\t\t$window.off('mousemove touchmove', this._eventListeners.move);\r\n\t\t$window.off('mouseup touchend touchcancel', this._eventListeners.end);\r\n\t\t$mainWrap.off('dragstart', this._eventListeners.dragStart);\r\n\t};\r\n\r\n\t/**\r\n\t * Called on drag start event.\r\n\t *\r\n\t * @method _onRawStart\r\n\t * @param {Event} e Raw event\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._onRawStart = function(e) {\r\n\t\tif (e.which !== 1 && e.type !== 'touchstart') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tvar orientation = this._carousel.getOrientation(),\r\n\t\t\thorizontal = orientation === this._carousel.Config.Orientation.HORIZONTAL,\r\n\t\t\tisTouchEvent = e.type === 'touchstart',\r\n\t\t\tx = isTouchEvent ? e.originalEvent.changedTouches[0].pageX : e.pageX,\r\n\t\t\ty = isTouchEvent ? e.originalEvent.changedTouches[0].pageY : e.pageY,\r\n\t\t\ttargetElement = e.target,\r\n\t\t\tresult;\r\n\r\n\t\tresult = this._begin(horizontal ? x : y, horizontal ? y : x, targetElement);\r\n\r\n\t\tif (result === false) {\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called on drag move event.\r\n\t *\r\n\t * @method _onRawMove\r\n\t * @param {Event} e Raw event\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._onRawMove = function(e) {\r\n\t\tvar orientation = this._carousel.getOrientation(),\r\n\t\t\thorizontal = orientation === this._carousel.Config.Orientation.HORIZONTAL,\r\n\t\t\tisTouchEvent = e.type === 'touchmove',\r\n\t\t\tresult,\r\n\t\t\tx,\r\n\t\t\ty;\r\n\r\n\t\t// stop if not active\r\n\t\tif (!this._active) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// only move the carousel when the left mouse button is pressed\r\n\t\tif (e.which !== 1 && e.type !== 'touchmove') {\r\n\t\t\tresult = this._end(e.target, isTouchEvent);\r\n\t\t} else {\r\n\t\t\tx = isTouchEvent ? e.originalEvent.changedTouches[0].pageX : e.pageX;\r\n\t\t\ty = isTouchEvent ? e.originalEvent.changedTouches[0].pageY : e.pageY;\r\n\r\n\t\t\tresult = this._move(horizontal ? x : y, horizontal ? y : x);\r\n\t\t}\r\n\r\n\t\tif (result === false) {\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called on drag end event.\r\n\t *\r\n\t * @method _onRawEnd\r\n\t * @param {Event} e Raw event\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._onRawEnd = function(e) {\r\n\t\tvar isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel',\r\n\t\t\tresult,\r\n\t\t\ttargetElement;\r\n\r\n\t\t// stop if not active\r\n\t\tif (!this._active) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// quit if invalid event\r\n\t\tif (e.which !== 1 && e.type !== 'touchend' && e.type !== 'touchcancel') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\ttargetElement = e.target;\r\n\r\n\t\tresult = this._end(targetElement, isTouchEvent);\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (result === false) {\r\n\t\t\te.preventDefault();\r\n\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called on main wrap drag start event.\r\n\t *\r\n\t * @method _onRawDragStart\r\n\t * @param {Event} e Drag start event\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._onRawDragStart = function(/*e*/) {\r\n\t\t// cancel start drag event so images, links etc couldn't be dragged\r\n        return false;\r\n\t};\r\n\r\n\t/**\r\n\t * Begins the navigation.\r\n\t *\r\n\t * @method _begin\r\n\t * @param {number} position Drag position\r\n\t * @param {number} oppositePosition Drag opposite position (y for horizontal, x for vertical)\r\n\t * @param {DOMElement} targetElement The element that was under the cursor when drag started\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._begin = function(position, oppositePosition, targetElement) {\r\n\t\ttargetElement = targetElement || null;\r\n\r\n\t\t// don't allow dragging when already animating\r\n\t\tif (this._carousel.isAnimating()) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tthis._active = true;\r\n\t\tthis._startPosition = position;\r\n\t\tthis._startOppositePosition = oppositePosition;\r\n\t\tthis._lastPosition = position; // it's possible that the move event never occurs so set it here alrady\r\n\t\tthis._lastOppositePosition = oppositePosition; // same for this\r\n\t\tthis._startCarouselPosition = this._carousel.getAnimator().getCurrentPosition();\r\n\t\tthis._startHoverItemIndex = this._carousel.getHoverItemIndex();\r\n\t\tthis._startWindowScrollTop = $(window).scrollTop();\r\n\t\tthis._accumulatedMagnitude = {\r\n\t\t\tmain: 0,\r\n\t\t\topposite: 0\r\n\t\t};\r\n\t\tthis._firstMoveEvent = true;\r\n\r\n\t\t// disable all children click events for the duration of the dragging\r\n\t\tif (targetElement !== null) {\r\n\t\t\tthis._startTargetElement = targetElement;\r\n\r\n\t\t\tthis._disableClickHandlers(targetElement);\r\n\t\t}\r\n\r\n\t\t// notify the carousel that dragging has begun\r\n\t\tthis._carousel._onDragBegin(\r\n\t\t\tthis._startPosition,\r\n\t\t\tthis._startOppositePosition,\r\n\t\t\tthis._startCarouselPosition,\r\n\t\t\tthis._startWindowScrollTop\r\n\t\t);\r\n\r\n\t\t// disable default functionality\r\n\t\t//return false;\r\n\r\n\t\t// do not disable scrolling the page from the carousel component\r\n\t\treturn true;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse/finger move.\r\n\t *\r\n\t * @method _move\r\n\t * @param {number} position Drag position\r\n\t * @param {number} oppositePosition Drag opposite position (y for horizontal, x for vertical)\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._move = function(position, oppositePosition) {\r\n\t\t/* istanbul ignore if */\r\n\t\tif (!this._active) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// compare motion in the carousel and the opposite direction\r\n\t\tvar deltaDragPosition = position - this._startPosition;\r\n\t\t\t//deltaDragOppositePosition = oppositePosition - this._startOppositePosition,\r\n\t\t\t//currentWindowScrollTop = $(window).scrollTop(),\r\n\t\t\t//windowScrollTopDifference = this._startWindowScrollTop - currentWindowScrollTop;\r\n\r\n\t\tthis._accumulatedMagnitude.main += Math.abs(this._lastPosition - position);\r\n\t\tthis._accumulatedMagnitude.opposite += Math.abs(this._lastOppositePosition - oppositePosition);\r\n\r\n\t\t// we need last move position in the _end() handler\r\n\t\tthis._lastPosition = position;\r\n\t\tthis._lastOppositePosition = oppositePosition;\r\n\r\n\t\t// if the drag delta is very small then do nothing not to quit or start moving too soon\r\n\t\t// TODO this deadband can not be done on android: https://code.google.com/p/chromium/issues/detail?id=240735\r\n\t\t/*if (this._accumulatedMagnitude.main < this._noActionThreshold) {\r\n\t\t\t// emulate manual scrolling\r\n\t\t\t//$(window).scrollTop(this._startWindowScrollTop - windowScrollTopDifference - deltaDragOppositePosition);\r\n\r\n\t\t\treturn false;\r\n\t\t}*/\r\n\r\n\t\t// if the carousel is dragged more in the opposite direction then cancel and propagate\r\n\t\t// this allows drag-navigating the page from carousel elements even if dead-band is exceeded\r\n\t\tif (\r\n\t\t\tthis._accumulatedMagnitude.main > 0\r\n\t\t\t&& this._accumulatedMagnitude.main < this._accumulatedMagnitude.opposite\r\n\t\t) {\r\n\t\t\tthis._end();\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// if the first move event takes more than 200ms then Android Chrome cancels the scroll, avoid this by returning\r\n\t\t// quikcly on the first event\r\n\t\tif (this._firstMoveEvent) {\r\n\t\t\tthis._firstMoveEvent = false;\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// calculate the position\r\n\t\tvar newPosition = this._startCarouselPosition + deltaDragPosition,\r\n\t\t\titemSize = this._carousel.getItemSize(),\r\n\t\t\ttotalSize = this._carousel.getTotalSize(),\r\n\t\t\titemCountOnLastPage = this._carousel.getItemCountOnLastPage(),\r\n\t\t\tedgeMultiplier = this._config.overEdgeDragPositionMultiplier,\r\n\t\t\tminLimit = 0,\r\n\t\t\tmaxLimit = -totalSize + itemCountOnLastPage * itemSize;\r\n\r\n\t\t// create smooth limit at the edges applying the drag motion partially\r\n\t\tif (newPosition > minLimit || newPosition < maxLimit) {\r\n\t\t\tnewPosition = this._startCarouselPosition + deltaDragPosition * edgeMultiplier;\r\n\t\t}\r\n\r\n\t\t// use the animator to move to calculated position instantly\r\n\t\tthis._carousel.getAnimator().animateToPosition(newPosition, true, true);\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on gesture end.\r\n\t *\r\n\t * @method _end\r\n\t * @param {DOMElement} targetElement The element that the drag ended on\r\n\t * @param {boolean} [isTouchEvent=false] Is this a touch event\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._end = function(targetElement, isTouchEvent) {\r\n\t\t/* istanbul ignore if */\r\n\t\tif (!this._active) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tisTouchEvent = typeof isTouchEvent === 'boolean' ? isTouchEvent : false;\r\n\r\n\t\tvar deltaDragPosition = this._lastPosition - this._startPosition,\r\n\t\t\tdeltaDragOppositePosition = this._lastOppositePosition - this._startOppositePosition,\r\n\t\t\tdragMagnitude = Math.sqrt(Math.pow(deltaDragPosition, 2) + Math.pow(deltaDragOppositePosition, 2)),\r\n\t\t\tdirection = deltaDragPosition < 0 ? -1 : 1,\r\n\t\t\tcurrentPosition = this._carousel.getAnimator().getCurrentPosition(),\r\n\t\t\tignoreClickThreshold = this._config.ignoreClickThreshold,\r\n\t\t\tperformNavigation = Math.abs(deltaDragPosition) > 0,\r\n\t\t\tpropagate = false,\r\n\t\t\tperformClick,\r\n\t\t\tclosestIndex,\r\n\t\t\tendHoverItemIndex;\r\n\r\n\t\t// we have to perform the navigation if the carousel was dragged in the main direction\r\n\t\tif (performNavigation) {\r\n\t\t\t// navigate to closest item or page depending on selected mode\r\n\t\t\tswitch (this._mode) {\r\n\t\t\t\tcase DragNavigator.Mode.NAVIGATE_PAGE:\r\n\t\t\t\t\tclosestIndex = this._carousel.getClosestPageIndexAtPosition(currentPosition, direction);\r\n\r\n\t\t\t\t\tthis._carousel.navigateToPage(closestIndex, false, true);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase DragNavigator.Mode.NAVIGATE_ITEM:\r\n\t\t\t\t\tclosestIndex = this._carousel.getClosestItemIndexAtPosition(currentPosition, direction);\r\n\r\n\t\t\t\t\tthis._carousel.navigateToItem(closestIndex, false, true);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// for touch events we don't have the hover indexes\r\n\t\tif (isTouchEvent) {\r\n\t\t\tperformClick = targetElement !== null\r\n\t\t\t\t&& targetElement === this._startTargetElement\r\n\t\t\t\t&& dragMagnitude < ignoreClickThreshold;\r\n\t\t} else {\r\n\t\t\tendHoverItemIndex = this._carousel.getHoverItemIndex();\r\n\r\n\t\t\tperformClick = this._startHoverItemIndex !== null\r\n\t\t\t\t&& targetElement !== null\r\n\t\t\t\t&& targetElement === this._startTargetElement\r\n\t\t\t\t&& endHoverItemIndex === this._startHoverItemIndex\r\n\t\t\t\t&& dragMagnitude < ignoreClickThreshold;\r\n\t\t}\r\n\r\n\t\t// restore the element click handler if drag stopped on the same element and was dragged very little\r\n\t\tif (performClick) {\r\n\t\t\tthis._restoreClickHandlers(targetElement);\r\n\r\n\t\t\tthis._dragStartHoverItemIndex = null;\r\n\r\n\t\t\t// make sure the event propagates so the correct listeners get fired\r\n\t\t\tpropagate = true;\r\n\t\t}\r\n\r\n\t\t// notify the carousel that dragging has begun\r\n\t\tthis._carousel._onDragEnd(\r\n\t\t\tthis._mode,\r\n\t\t\tthis._startPosition,\r\n\t\t\tthis._lastPosition,\r\n\t\t\tdeltaDragPosition,\r\n\t\t\tclosestIndex,\r\n\t\t\tdirection,\r\n\t\t\ttargetElement\r\n\t\t);\r\n\r\n\t\t// reset\r\n\t\tthis._active = false;\r\n\t\tthis._startPosition = null;\r\n\t\tthis._startOppositePosition = null;\r\n\t\tthis._startCarouselPosition = null;\r\n\t\tthis._startWindowScrollTop = null;\r\n\t\tthis._lastPosition = null;\r\n\t\tthis._accumulatedMagnitude = {\r\n\t\t\tmain: 0,\r\n\t\t\topposite: 0\r\n\t\t};\r\n\t\tthis._firstMoveEvent = true;\r\n\r\n\t\treturn propagate;\r\n\t};\r\n\r\n\t/**\r\n\t * Disables normal click handler for given element.\r\n\t *\r\n\t * @method _disableClickHandlers\r\n\t * @param {DOMElement} clickedElement Element to disable click events on\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._disableClickHandlers = function(clickedElement) {\r\n\t\tvar disabledDataName = this._carousel.getConfig().cssPrefix + 'click-disabled',\r\n\t\t\t$clickedElement = $(clickedElement),\r\n\t\t\t$closestLink = $clickedElement.closest('A'),\r\n\t\t\t$disableElement = $clickedElement,\r\n\t\t\tisAlreadyDisabled,\r\n\t\t\tmainWrapClass,\r\n\t\t\tlinkHasCarouselParent;\r\n\r\n\t\t// disable the closest A if possible\r\n\t\tif ($closestLink.length > 0) {\r\n\t\t\tmainWrapClass = '.' + this._carousel.getConfig().getClassName('wrap');\r\n\t\t\tlinkHasCarouselParent = $closestLink.closest(mainWrapClass).length > 0;\r\n\r\n\t\t\tif (linkHasCarouselParent) {\r\n\t\t\t\t$disableElement = $closestLink;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tisAlreadyDisabled = $disableElement.data(disabledDataName);\r\n\r\n\t\tif (isAlreadyDisabled !== true) {\r\n\t\t\tvar currentEventHandlers = $._data(clickedElement, 'events'),\r\n\t\t\t\tclickHandlerFunctions = [],\r\n\t\t\t\tcurrentClickHandlers,\r\n\t\t\t\ti;\r\n\r\n\t\t\t// extract the existing click event handlers if got any\r\n\t\t\tif (\r\n\t\t\t\tUtil.isObject(currentEventHandlers)\r\n\t\t\t\t&& Util.isArray(currentEventHandlers.click)\r\n\t\t\t\t&& currentEventHandlers.click.length > 0\r\n\t\t\t) {\r\n\t\t\t\t// extract the current clickhandler functions\r\n\t\t\t\tcurrentClickHandlers = currentEventHandlers.click;\r\n\r\n\t\t\t\tfor (i = 0; i < currentClickHandlers.length; i++) {\r\n\t\t\t\t\tclickHandlerFunctions.push(currentClickHandlers[i].handler);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// store the original click handlers\r\n\t\t\t\t$disableElement.data('original-click-handlers', clickHandlerFunctions);\r\n\r\n\t\t\t\t// remove the current click handlers and add the ignore handler\r\n\t\t\t\t$disableElement.off('click');\r\n\t\t\t}\r\n\r\n\t\t\t// add an ignoring click handler\r\n\t\t\t$disableElement.on('click', this._ignoreEvent);\r\n\r\n\t\t\t$disableElement.data(disabledDataName, true);\r\n\r\n\t\t\t// mark it disabled to be easy to find for restoring\r\n\t\t\t$disableElement.attr('data-disabled', 'true');\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Calls the original click handlers for given element.\r\n\t *\r\n\t * @method _restoreClickHandlers\r\n\t * @param {DOMElement} clickedElement Element to disable click events on\r\n\t * @private\r\n\t */\r\n\tDragNavigator.prototype._restoreClickHandlers = function(clickedElement) {\r\n\t\tvar disabledDataName = this._carousel.getConfig().cssPrefix + 'click-disabled',\r\n\t\t\t$clickedElement = $(clickedElement),\r\n\t\t\t$restoreElement = null,\r\n\t\t\t$closestLink;\r\n\r\n\t\t// find the disabled element\r\n\t\tif ($clickedElement.attr('data-disabled') === 'true') {\r\n\t\t\t$restoreElement = $clickedElement;\r\n\t\t} else {\r\n\t\t\t$closestLink = $clickedElement.closest('A');\r\n\r\n\t\t\tif ($closestLink.length > 0 && $closestLink.attr('data-disabled') === 'true') {\r\n\t\t\t\t$restoreElement = $closestLink;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// this should generally not happen\r\n\t\tif ($restoreElement === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar originalClickHandlers = $restoreElement.data('original-click-handlers'),\r\n\t\t\ti;\r\n\r\n\t\t// remove the ignore handler\r\n\t\t$restoreElement.off('click');\r\n\r\n\t\t// restore the old click handlers if present\r\n\t\tif (Util.isArray(originalClickHandlers)) {\r\n\t\t\t// restore the original click handlers\r\n\t\t\tfor (i = 0; i < originalClickHandlers.length; i++) {\r\n\t\t\t\t$restoreElement.on('click', originalClickHandlers[i].bind(clickedElement));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// remove the disabled state\r\n\t\t$restoreElement.data(disabledDataName, false);\r\n\t\t$restoreElement.attr('data-disabled', null);\r\n\r\n\t\t/*var $clickedElement = $(clickedElement),\r\n\t\t\tdisabledDataName = this._carousel.getConfig().cssPrefix + 'click-disabled',\r\n\t\t\tisDisabled = $clickedElement.data(disabledDataName);\r\n\r\n\t\tif (isDisabled === true) {\r\n\t\t\t// fetch the original click handlers\r\n\t\t\tvar originalClickHandlers = $clickedElement.data('original-click-handlers'),\r\n\t\t\t\ti;\r\n\r\n\t\t\t// remove the ignore handler\r\n\t\t\t$clickedElement.off('click');\r\n\r\n\t\t\t// restore the old click handlers if present\r\n\t\t\tif (Util.isArray(originalClickHandlers)) {\r\n\t\t\t\t// restore the original click handlers\r\n\t\t\t\tfor (i = 0; i < originalClickHandlers.length; i++) {\r\n\t\t\t\t\t$clickedElement.on('click', originalClickHandlers[i].bind(clickedElement));\r\n\r\n\t\t\t\t\t//originalClickHandlers[i].call(element);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$clickedElement.data(disabledDataName, false);\r\n\t\t}*/\r\n\t};\r\n\r\n\t/**\r\n\t * Ignores given jQuery event.\r\n\t *\r\n\t * TODO don't know how to unit-test this yet\r\n\t *\r\n\t * @method _ignoreEvent\r\n\t * @param {jQuery.Event} e jQuery event\r\n\t * @return {boolean} Should the event propagate\r\n\t * @private\r\n\t */\r\n\t/* istanbul ignore next */\r\n\tDragNavigator.prototype._ignoreEvent = function(e) {\r\n\t\te.preventDefault();\r\n\t\te.stopPropagation();\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\treturn DragNavigator;\r\n});\n","define('SlideshowNavigator',[\r\n\t'AbstractNavigator',\r\n\t'Util'\r\n], function(AbstractNavigator, Util) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Automatic slideshow navigator.\r\n\t *\r\n\t * @class SlideshowNavigator\r\n\t * @extends AbstractNavigator\r\n\t * @param {object} config Navigator configuration\r\n\t * @constructor\r\n\t */\r\n\tfunction SlideshowNavigator(config) {\r\n\t\tAbstractNavigator.call(this);\r\n\r\n\t\tthis._config = config;\r\n\t\tthis._mode = null;\r\n\t\tthis._delayTimeout = null;\r\n\t\tthis._playing = false;\r\n\t\tthis._mouseEntered = false;\r\n\r\n\t\tthis._eventListeners = {\r\n\t\t\tmouseenter: this._onRawMouseEnter.bind(this),\r\n\t\t\tmouseleave: this._onRawMouseLeave.bind(this)\r\n\t\t};\r\n\r\n\t\tthis.setMode(config.mode || SlideshowNavigator.Mode.NAVIGATE_PAGE);\r\n\t}\r\n\r\n\tSlideshowNavigator.prototype = Object.create(AbstractNavigator.prototype);\r\n\r\n\t/**\r\n\t * List of supported navigation modes.\r\n\t *\r\n\t * @property Mode\r\n\t * @type {object}\r\n\t * @param {string} Mode.NAVIGATE_PAGE='navigate-page' Navigate one page at a time\r\n\t * @param {string} Mode.NAVIGATE_ITEM='navigate-item' Navigate one item at a time\r\n\t */\r\n\tSlideshowNavigator.Mode = {\r\n\t\tNAVIGATE_PAGE: 'navigate-page',\r\n\t\tNAVIGATE_ITEM: 'navigate-item'\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current slideshow navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"SlideshowNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"SlideshowNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that slideshow changes\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method setMode\r\n\t * @param {SlideshowNavigator/Mode:property} mode Mode to use\r\n\t */\r\n\tSlideshowNavigator.prototype.setMode = function(mode) {\r\n\t\tif (!Util.objectHasValue(SlideshowNavigator.Mode, mode)) {\r\n\t\t\tthrow new Error('Invalid mode \"' + mode + '\" provided');\r\n\t\t}\r\n\r\n\t\tthis._mode = mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current slideshow navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"SlideshowNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"SlideshowNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that slideshow changes\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method getMode\r\n\t * @return {SlideshowNavigator/Mode:property}\r\n\t */\r\n\tSlideshowNavigator.prototype.getMode = function() {\r\n\t\treturn this._mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the init to set up the navigator.\r\n\t *\r\n\t * @method _setup\r\n\t * @protected\r\n\t */\r\n\tSlideshowNavigator.prototype._setup = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap());\r\n\r\n\t\t// make sure that the mouse if over the main wrap element\r\n\t\t$mainWrap\r\n\t\t\t.on('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.on('mouseleave', this._eventListeners.mouseleave);\r\n\r\n\t\tthis._carousel.on(this._carousel.Event.NAVIGATED_TO_ITEM, this._onNavigatedToItem.bind(this));\r\n\r\n\t\tthis.start();\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tSlideshowNavigator.prototype.destroy = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap());\r\n\r\n\t\tthis.stop();\r\n\r\n\t\t// remove the event listeners\r\n\t\t$mainWrap\r\n\t\t\t.off('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.off('mouseleave', this._eventListeners.mouseleave);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether the slideshow is currently playing.\r\n\t *\r\n\t * @method isActive\r\n\t */\r\n\tSlideshowNavigator.prototype.isPlaying = function() {\r\n\t\treturn this._playing;\r\n\t};\r\n\r\n\t/**\r\n\t * Starts the automatic slideshow.\r\n\t *\r\n\t * @method start\r\n\t */\r\n\tSlideshowNavigator.prototype.start = function() {\r\n\t\tif (this.isPlaying()) {\r\n\t\t\tthis.stop();\r\n\t\t}\r\n\r\n\t\tthis._playing = true;\r\n\r\n\t\tthis._scheduleNextChange();\r\n\t};\r\n\r\n\t/**\r\n\t * Starts the automatic slideshow.\r\n\t *\r\n\t * @method start\r\n\t */\r\n\tSlideshowNavigator.prototype.stop = function() {\r\n\t\tif (this._delayTimeout !== null) {\r\n\t\t\twindow.clearTimeout(this._delayTimeout);\r\n\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\tthis._playing = false;\r\n\t};\r\n\r\n\t/**\r\n\t * Schedules the next change event.\r\n\t *\r\n\t * @method _scheduleNextChange\r\n\t * @private\r\n\t */\r\n\tSlideshowNavigator.prototype._scheduleNextChange = function() {\r\n\t\tif (!this.isPlaying()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar interval = this._config.interval;\r\n\r\n\t\t// clear existing\r\n\t\tif (this._delayTimeout !== null) {\r\n\t\t\twindow.clearTimeout(this._delayTimeout);\r\n\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// perform action after timeout and schedule another one\r\n\t\tthis._delayTimeout = window.setTimeout(function() {\r\n\t\t\tif (this._carousel === null || !this._carousel.isInitiated()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis._performChange();\r\n\t\t\tthis._scheduleNextChange();\r\n\t\t}.bind(this), interval);\r\n\t};\r\n\r\n\t/**\r\n\t * Performs the change event.\r\n\t *\r\n\t * @method _performChange\r\n\t * @private\r\n\t */\r\n\tSlideshowNavigator.prototype._performChange = function() {\r\n\t\t// don't control the carousel when user is hovering it\r\n\t\tif (this._mouseEntered) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar instantRollover = this._config.instantRollover;\r\n\r\n\t\tif (this._mode === SlideshowNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\tif (this._carousel.getPageCount() > 0) {\r\n\t\t\t\tif (this._carousel.isLastPage()) {\r\n\t\t\t\t\tthis._carousel.navigateToPage(0, instantRollover);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._carousel.navigateToNextPage();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (this._mode === SlideshowNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\tif (this._carousel.getItemCount() > 0) {\r\n\t\t\t\tif (this._carousel.isLastItem()) {\r\n\t\t\t\t\tthis._carousel.navigateToItem(0, instantRollover);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._carousel.navigateToNextItem();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseEnter\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tSlideshowNavigator.prototype._onRawMouseEnter = function(/*e*/) {\r\n\t\tthis._mouseEntered = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseLeave\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tSlideshowNavigator.prototype._onRawMouseLeave = function(/*e*/) {\r\n\t\tthis._mouseEntered = false;\r\n\r\n\t\t// re-schedule the change event for consistent timing\r\n\t\tthis._scheduleNextChange();\r\n\t};\r\n\r\n\t/**\r\n\t * Called when user navigated to a new item.\r\n\t *\r\n\t * @method _onNavigatedToItem\r\n\t * @private\r\n\t */\r\n\tSlideshowNavigator.prototype._onNavigatedToItem = function() {\r\n\t\t// re-schedule the change event for consistent timing\r\n\t\tthis._scheduleNextChange();\r\n\t};\r\n\r\n\treturn SlideshowNavigator;\r\n});\n","define('InterfaceNavigator',[\r\n\t'AbstractNavigator',\r\n\t'Util'\r\n], function(AbstractNavigator, Util) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Build a user interface for navigating the carousel.\r\n\t *\r\n\t * @class InterfaceNavigator\r\n\t * @extends AbstractNavigator\r\n\t * @param {object} config Navigator configuration\r\n\t * @constructor\r\n\t */\r\n\tfunction InterfaceNavigator(config) {\r\n\t\tAbstractNavigator.call(this);\r\n\r\n\t\tthis._config = config;\r\n\t\tthis._mode = null;\r\n\t\tthis._mouseEntered = false;\r\n\r\n\t\tthis._eventListeners = {\r\n\t\t\tmouseenter: this._onRawMouseEnter.bind(this),\r\n\t\t\tmouseleave: this._onRawMouseLeave.bind(this)\r\n\t\t};\r\n\r\n\t\tthis.setMode(config.mode || InterfaceNavigator.Mode.NAVIGATE_PAGE);\r\n\t}\r\n\r\n\tInterfaceNavigator.prototype = Object.create(AbstractNavigator.prototype);\r\n\r\n\t/**\r\n\t * List of supported navigation modes.\r\n\t *\r\n\t * @property Mode\r\n\t * @type {object}\r\n\t * @param {string} Mode.NAVIGATE_PAGE='navigate-page' Navigate one page at a time\r\n\t * @param {string} Mode.NAVIGATE_ITEM='navigate-item' Navigate one item at a time\r\n\t */\r\n\tInterfaceNavigator.Mode = {\r\n\t\tNAVIGATE_PAGE: 'navigate-page',\r\n\t\tNAVIGATE_ITEM: 'navigate-item'\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current interface navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"InterfaceNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"InterfaceNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that slideshow changes\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method setMode\r\n\t * @param {InterfaceNavigator/Mode:property} mode Mode to use\r\n\t */\r\n\tInterfaceNavigator.prototype.setMode = function(mode) {\r\n\t\tif (!Util.objectHasValue(InterfaceNavigator.Mode, mode)) {\r\n\t\t\tthrow new Error('Invalid mode \"' + mode + '\" provided');\r\n\t\t}\r\n\r\n\t\tthis._mode = mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current interface navigator mode.\r\n\t *\r\n\t * The mode is either {{#crossLink \"InterfaceNavigator/Mode/NAVIGATE_PAGE:property\"}}{{/crossLink}} or\r\n\t * {{#crossLink \"InterfaceNavigator/Mode/NAVIGATE_ITEM:property\"}}{{/crossLink}} meaning that buttons change\r\n\t * either the page or navigate one item at a time.\r\n\t *\r\n\t * @method getMode\r\n\t * @return {InterfaceNavigator/Mode:property}\r\n\t */\r\n\tInterfaceNavigator.prototype.getMode = function() {\r\n\t\treturn this._mode;\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the init to set up the navigator.\r\n\t *\r\n\t * @method _setup\r\n\t * @protected\r\n\t */\r\n\tInterfaceNavigator.prototype._setup = function() {\r\n\t\tvar $mainWrap = $(this._carousel.getMainWrap());\r\n\r\n\t\t// make sure that the mouse if over the main wrap element\r\n\t\t$mainWrap\r\n\t\t\t.on('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.on('mouseleave', this._eventListeners.mouseleave);\r\n\r\n\t\tthis._carousel.on(this._carousel.Event.NAVIGATING_TO_ITEM, this._onNavigatingToItem.bind(this));\r\n\t\tthis._carousel.on(this._carousel.Event.LAYOUT_CHANGED, this._onLayoutChanged.bind(this));\r\n\r\n\t\tthis._redraw();\r\n\t};\r\n\r\n\t/**\r\n\t * Build the user interface.\r\n\t *\r\n\t * @method _redraw\r\n\t * @protected\r\n\t */\r\n\tInterfaceNavigator.prototype._redraw = function() {\r\n\t\tvar cssPrefix = this._carousel.getConfig().cssPrefix,\r\n\t\t\tclassName = {\r\n\t\t\t\twrap: cssPrefix + 'interface',\r\n\t\t\t\titemChoice: cssPrefix + 'item-choice'\r\n\t\t\t},\r\n\t\t\titemCount = this._config.mode === 'navigate-page'\r\n\t\t\t\t? this._carousel.getPageCount()\r\n\t\t\t\t: this._carousel.getItemCount(),\r\n\t\t\t$mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$interfaceWrap = $('<div/>', {\r\n\t\t\t\t'class': className.wrap\r\n\t\t\t}),\r\n\t\t\t$itemChoiceWrap = $('<ul/>', {\r\n\t\t\t\t'class': className.itemChoice\r\n\t\t\t}).appendTo($interfaceWrap),\r\n\t\t\t$itemChoiceElement,\r\n\t\t\ti;\r\n\r\n\t\t// remove existing interface if exists\r\n\t\t$mainWrap.find('.' + className.wrap).remove();\r\n\r\n\t\tif (itemCount > 1) {\r\n\t\t\t// create the item choice items\r\n\t\t\tfor (i = 0; i < itemCount; i++) {\r\n\t\t\t\t$itemChoiceElement = $('<li/>').text(i + 1).appendTo($itemChoiceWrap);\r\n\r\n\t\t\t\t$itemChoiceElement.click(function (index, e) {\r\n\t\t\t\t\tthis._onItemChoiceClick(e.target, index);\r\n\t\t\t\t}.bind(this, i));\r\n\t\t\t}\r\n\r\n\t\t\t// add the new one\r\n\t\t\t$mainWrap.append($interfaceWrap);\r\n\r\n\t\t\t// set the initially active element\r\n\t\t\tthis._updateActiveItemChoice();\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called when any of the item choice elements are clicked.\r\n\t *\r\n\t * @method _onItemChoiceClick\r\n\t * @param {DOMElement} element Clicked element\r\n\t * @param {number} index Item index\r\n\t * @protected\r\n\t */\r\n\tInterfaceNavigator.prototype._onItemChoiceClick = function(element, index) {\r\n\t\tif (this._mode === InterfaceNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\tthis._carousel.navigateToPage(index);\r\n\t\t} else if (this._mode === InterfaceNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\tthis._carousel.navigateToItem(index);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tInterfaceNavigator.prototype.destroy = function() {\r\n\t\tvar cssPrefix = this._carousel.getConfig().cssPrefix,\r\n\t\t\tclassName = {\r\n\t\t\t\twrap: cssPrefix + 'interface',\r\n\t\t\t},\r\n\t\t\t$mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$interfaceWrap = $mainWrap.find('.' + className.wrap);\r\n\r\n\t\t// remove the interface element\r\n\t\t$interfaceWrap.remove();\r\n\r\n\t\t// remove the event listeners\r\n\t\t$mainWrap\r\n\t\t\t.off('mouseenter', this._eventListeners.mouseenter)\r\n\t\t\t.off('mouseleave', this._eventListeners.mouseleave);\r\n\t};\r\n\r\n\t/**\r\n\t * Performs the change event.\r\n\t *\r\n\t * @method _performChange\r\n\t * @private\r\n\t */\r\n\t/*InterfaceNavigator.prototype._performChange = function() {\r\n\t\t// don't control the carousel when user is hovering it\r\n\t\tif (this._mouseEntered) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar instantRollover = this._config.instantRollover;\r\n\r\n\t\tif (this._mode === InterfaceNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\tif (this._carousel.getPageCount() > 0) {\r\n\t\t\t\tif (this._carousel.isLastPage()) {\r\n\t\t\t\t\tthis._carousel.navigateToPage(0, instantRollover);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._carousel.navigateToNextPage();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (this._mode === InterfaceNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\tif (this._carousel.getItemCount() > 0) {\r\n\t\t\t\tif (this._carousel.isLastItem()) {\r\n\t\t\t\t\tthis._carousel.navigateToItem(0, instantRollover);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._carousel.navigateToNextItem();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};*/\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseEnter\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tInterfaceNavigator.prototype._onRawMouseEnter = function(/*e*/) {\r\n\t\tthis._mouseEntered = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on mouse enter event.\r\n\t *\r\n\t * @method _onRawMouseLeave\r\n\t * @param {Event} e Mouse event\r\n\t * @private\r\n\t */\r\n\tInterfaceNavigator.prototype._onRawMouseLeave = function(/*e*/) {\r\n\t\tthis._mouseEntered = false;\r\n\t};\r\n\r\n\t/**\r\n\t * Called when user navigated to a new item.\r\n\t *\r\n\t * @method _onNavigatingToItem\r\n\t * @private\r\n\t */\r\n\tInterfaceNavigator.prototype._onNavigatingToItem = function() {\r\n\t\tthis._updateActiveItemChoice();\r\n\t};\r\n\r\n\t/**\r\n\t * Gives the right element the active item class.\r\n\t *\r\n\t * @method _updateActiveItemChoice\r\n\t * @private\r\n\t */\r\n\tInterfaceNavigator.prototype._updateActiveItemChoice = function() {\r\n\t\tvar cssPrefix = this._carousel.getConfig().cssPrefix,\r\n\t\t\tclassName = {\r\n\t\t\t\twrap: cssPrefix + 'interface',\r\n\t\t\t\titemChoice: cssPrefix + 'item-choice',\r\n\t\t\t\tisActive: cssPrefix + 'active-item-choice'\r\n\t\t\t},\r\n\t\t\t$mainWrap = $(this._carousel.getMainWrap()),\r\n\t\t\t$interfaceWrap = $mainWrap.find('.' + className.wrap),\r\n\t\t\t$itemChoiceWrap = $interfaceWrap.find('.' + className.itemChoice),\r\n\t\t\ttargetItemIndex = this._carousel.getTargetItemIndex(),\r\n\t\t\t$itemChoiceElement,\r\n\t\t\titemIndex;\r\n\r\n\t\tif (this._mode === InterfaceNavigator.Mode.NAVIGATE_PAGE) {\r\n\t\t\titemIndex = this._carousel.getItemPageIndex(targetItemIndex);\r\n\t\t} else if (this._mode === InterfaceNavigator.Mode.NAVIGATE_ITEM) {\r\n\t\t\titemIndex = targetItemIndex;\r\n\t\t}\r\n\r\n\t\t$itemChoiceElement = $itemChoiceWrap.find('LI:eq(' + itemIndex + ')');\r\n\r\n\t\t$itemChoiceWrap.find('LI.' + className.isActive).removeClass(className.isActive);\r\n\t\t$itemChoiceElement.addClass(className.isActive);\r\n\t};\r\n\r\n\t/**\r\n\t * Called when the carousel layout changes.\r\n\t *\r\n\t * @method _onLayoutChanged\r\n\t * @private\r\n\t */\r\n\tInterfaceNavigator.prototype._onLayoutChanged = function() {\r\n\t\tthis._redraw();\r\n\t};\r\n\r\n\treturn InterfaceNavigator;\r\n});\n","define('Config',[\r\n\t'jquery',\r\n\t'Deferred',\r\n\t'KeyboardNavigator',\r\n\t'DragNavigator',\r\n\t'SlideshowNavigator',\r\n\t'InterfaceNavigator',\r\n], function($, Deferred, KeyboardNavigator, DragNavigator, SlideshowNavigator, InterfaceNavigator) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Provides configuration.\r\n\t *\r\n\t * @class Config\r\n\t * @constructor\r\n\t */\r\n\tfunction Config() {\r\n\r\n\t\t/**\r\n\t\t * Carousel orientation to use.\r\n\t\t *\r\n\t\t * One of {{#crossLink \"Config/Orientation:property\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * Defaults to horizontal.\r\n\t\t *\r\n\t\t * @property orientation\r\n\t\t * @type {Config/Orientation:property}\r\n\t\t * @default Config.Orientation.VERTICAL\r\n\t\t */\r\n\t\tthis.orientation = Config.Orientation.HORIZONTAL;\r\n\r\n\t\t/**\r\n\t\t * The size mode to use, defaults to matching item sizes to wrap size.\r\n\t\t *\r\n\t\t * @property sizeMode\r\n\t\t * @type {Config/SizeMode:property}\r\n\t\t * @default Config.SizeMode.MATCH_WRAP\r\n\t\t */\r\n\t\tthis.sizeMode = Config.SizeMode.MATCH_WRAP;\r\n\r\n\t\t/**\r\n\t\t * Item margin to use.\r\n\t\t *\r\n\t\t * @property margin\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.margin = 0;\r\n\r\n\t\t/**\r\n\t\t * Should placeholders be generated while loading actual items.\r\n\t\t *\r\n\t\t * @property usePlaceholders\r\n\t\t * @type boolean\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.usePlaceholders = true;\r\n\r\n\t\t/**\r\n\t\t * Should responsive layout be used by default.\r\n\t\t *\r\n\t\t * @property useResponsiveLayout\r\n\t\t * @type boolean\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.useResponsiveLayout = true;\r\n\r\n\t\t/**\r\n\t\t * Number of items to render side-by-side when not using responsive layout.\r\n\t\t *\r\n\t\t * This parameter is ignored when using responsive layout strategy.\r\n\t\t *\r\n\t\t * @property itemsPerPage\r\n\t\t * @type number\r\n\t\t * @default 5\r\n\t\t */\r\n\t\tthis.itemsPerPage = 5;\r\n\r\n\t\t/**\r\n\t\t * The index of the element to scroll to at startup.\r\n\t\t *\r\n\t\t * Set to a number value of valid range to enable.\r\n\t\t *\r\n\t\t * Defaults to showing the first element.\r\n\t\t *\r\n\t\t * Set either this or the {{#crossLink \"Config/startPageIndex:property\"}}{{/crossLink}} property, setting both\r\n\t\t * throws error.\r\n\t\t *\r\n\t\t * @property startItemIndex\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.startItemIndex = null;\r\n\r\n\t\t/**\r\n\t\t * The index of the page to scroll to at startup.\r\n\t\t *\r\n\t\t * Set to a number value of valid range to enable.\r\n\t\t *\r\n\t\t * Defaults to showing the first element.\r\n\t\t *\r\n\t\t * Set either this or the {{#crossLink \"Config/startItemIndex:property\"}}{{/crossLink}} property, setting both\r\n\t\t * throws error.\r\n\t\t *\r\n\t\t * @property startPageIndex\r\n\t\t * @type {number}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.startPageIndex = null;\r\n\r\n\t\t/**\r\n\t\t * If item or page start index is set then should it animate to it or should the position be set immediately.\r\n\t\t *\r\n\t\t * Applies to both {{#crossLink \"Config/startIndex:property\"}}{{/crossLink}} and\r\n\t\t * {{#crossLink \"Config/startPageIndex:property\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * By default the position is set without animation.\r\n\t\t *\r\n\t\t * @property animateToStartIndex\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.animateToStartIndex = false;\r\n\r\n\t\t/**\r\n\t\t * When using the {{#crossLink \"Config/startItemIndex:property\"}}{{/crossLink}} property, should the carousel\r\n\t\t * try to center on this item index rather than making it the first one.\r\n\t\t *\r\n\t\t * @property centerStartItemIndex\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.centerStartItemIndex = false;\r\n\r\n\t\t/**\r\n\t\t * List of default responsive layout breakpoint.\r\n\t\t *\r\n\t\t * The list should be ordered from the smallest size to the largest.\r\n\t\t *\r\n\t\t * @property responsiveBreakpoints\r\n\t\t * @type array\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.responsiveBreakpoints = [{\r\n\t\t\tsize: 0,\r\n\t\t\titemsPerPage: 1\r\n\t\t}, {\r\n\t\t\tsize: 320,\r\n\t\t\titemsPerPage: 2\r\n\t\t}, {\r\n\t\t\t//size: 768,\r\n\t\t\tsize: 560, // TODO remove\r\n\t\t\titemsPerPage: 3\r\n\t\t}, {\r\n\t\t\tsize: 1224,\r\n\t\t\titemsPerPage: 4\r\n\t\t}, {\r\n\t\t\tsize: 1824,\r\n\t\t\titemsPerPage: 5\r\n\t\t}];\r\n\r\n\t\t/**\r\n\t\t * The interval at which to check for carousel wrap size changes so responsive layout could be applied.\r\n\t\t *\r\n\t\t * Value is in milliseconds.\r\n\t\t *\r\n\t\t * @property responsiveLayoutListenerInterval\r\n\t\t * @type {number}\r\n\t\t * @default 100\r\n\t\t */\r\n\t\tthis.responsiveLayoutListenerInterval = 100;\r\n\r\n\t\t/**\r\n\t\t * How long to wait for the wrap size to stay the same before starting the responsive layout routine.\r\n\t\t *\r\n\t\t * This is useful so when the user is resizing the browser window then the carousel won't try to re-layout\r\n\t\t * itself on every frame but rather waits for the size to normalize.\r\n\t\t *\r\n\t\t * Value is in milliseconds.\r\n\t\t *\r\n\t\t * @property responsiveLayoutDelay\r\n\t\t * @type {number}\r\n\t\t * @default 300\r\n\t\t */\r\n\t\tthis.responsiveLayoutDelay = 500;\r\n\r\n\t\t/**\r\n\t\t * List of navigators to use with their configuration and factories.\r\n\t\t *\r\n\t\t * The \"createInstance(carousel)\" factory method gets the carousel instance as its only parameter and should\r\n\t\t * either return a navigator instance directly or a deferred promise that will be resolved with a navigator\r\n\t\t * instance.\r\n\t\t *\r\n\t\t * @property navigators\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.navigators = {\r\n\t\t\tkeyboard: {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tmode: 'navigate-page',\r\n\t\t\t\tcreateInstance: function(carousel) {\r\n\t\t\t\t\treturn new KeyboardNavigator(carousel.getConfig().navigators.keyboard);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdrag: {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tmode: 'navigate-page',\r\n\t\t\t\toverEdgeDragPositionMultiplier: 0.2,\r\n\t\t\t\tignoreClickThreshold: 10,\r\n\t\t\t\tcreateInstance: function(carousel) {\r\n\t\t\t\t\treturn new DragNavigator(carousel.getConfig().navigators.drag);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tslideshow: {\r\n\t\t\t\tenabled: false,\r\n\t\t\t\tmode: 'navigate-page',\r\n\t\t\t\tinterval: 3000,\r\n\t\t\t\tinstantRollover: true,\r\n\t\t\t\tcreateInstance: function(carousel) {\r\n\t\t\t\t\treturn new SlideshowNavigator(carousel.getConfig().navigators.slideshow);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinterface: {\r\n\t\t\t\tenabled: false,\r\n\t\t\t\tmode: 'navigate-page',\r\n\t\t\t\tcreateInstance: function(carousel) {\r\n\t\t\t\t\treturn new InterfaceNavigator(carousel.getConfig().navigators.slideshow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * The css classes prefix to use.\r\n\t\t *\r\n\t\t * The same prefix is also used when assigning custom carousel-specific data to the element.\r\n\t\t *\r\n\t\t * @property cssPrefix\r\n\t\t * @type {string}\r\n\t\t * @default 'flow-carousel-'\r\n\t\t */\r\n\t\tthis.cssPrefix = 'flow-carousel-';\r\n\r\n\t\t/**\r\n\t\t * CSS class names to use.\r\n\t\t *\r\n\t\t * The class name is combined with the {{#crossLink \"Config/cssPrefix:property\"}}{{/crossLink}} property\r\n\t\t * so if the prefix is \"flow-carousel-\" and the wrap class is \"wrap\" then the main wrap will get the\r\n\t\t * \"flow-carousel-wrap\" class.\r\n\t\t *\r\n\t\t * @property cssClasses\r\n\t\t * @param {string} cssClasses.wrap='wrap' Assigned to the main wrap element\r\n\t\t * @param {string} cssClasses.items='items' Assigned to the items wrap element in the main wrap\r\n\t\t * @param {string} cssClasses.scroller='scroller' Assigned to the animated scroller wrap in the items wrap\r\n\t\t * @param {string} cssClasses.item='item' Assigned to each item wrapper containing the actual item\r\n\t\t * @param {string} cssClasses.itemHover='item-hover' Assigned to item wrapper on hover and removed on mouse out\r\n\t\t * @param {string} cssClasses.placeholder='placeholder' Assigned to each item wrapper that is a placeholder\r\n\t\t * @param {string} cssClasses.matchWrap='match-wrap' Assigned to main wrap when using the wrap size match mode\r\n\t\t * @param {string} cssClasses.matchLargestItem='match-largest-item' Assigned to main wrap when matching the wrap\r\n\t\t * \t\t\t\t   size to the largest item size\r\n\t\t * @param {string} cssClasses.horizontal='horizontal' Assigned to main wrap for horizontal orientation\r\n\t\t * @param {string} cssClasses.vertical='vertical' Assigned to main wrap for vertical orientation\r\n\t\t * @param {string} cssClasses.animateTransform='animate-transform' With this class added the transforms get\r\n\t\t * \t\t\t\t   animated as well\r\n\t\t * @param {string} cssClasses.initiating='initiating' Assigned to main wrap during initialization procedure\r\n\t\t * @param {string} cssClasses.loading='loading' Assigned to main wrap during loading of items\r\n\t\t * @param {string} cssClasses.rendering='rendering' Assigned to main wrap during rendering of items\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.cssClasses = {\r\n\t\t\twrap: 'wrap',\r\n\t\t\titems: 'items',\r\n\t\t\tscroller: 'scroller',\r\n\t\t\titem: 'item',\r\n\t\t\tplaceholder: 'placeholder',\r\n\t\t\titemHover: 'item-hover',\r\n\t\t\tmatchWrap: 'match-wrap',\r\n\t\t\tmatchLargestItem: 'match-largest-item',\r\n\t\t\thorizontal: 'horizontal',\r\n\t\t\tvertical: 'vertical',\r\n\t\t\tanimateTransform: 'animate-transform',\r\n\t\t\tinitiating: 'initiating',\r\n\t\t\tloading: 'loading',\r\n\t\t\trendering: 'rendering'\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * The carousel instance is registered as the main wrap data with the dataTarget name.\r\n\t\t *\r\n\t\t * @property dataTarget\r\n\t\t * @type {string}\r\n\t\t * @default 'flow-carousel'\r\n\t\t */\r\n\t\tthis.dataTarget = 'flow-carousel';\r\n\r\n\t\t/**\r\n\t\t * Optional custom data source to use.\r\n\t\t *\r\n\t\t * As a special case, a simple array can be provided as data source which is converted to use\r\n\t\t * {{#crossLink \"ArrayDataSource\"}}{{/crossLink}} implementation.\r\n\t\t *\r\n\t\t * If none is provided then the {{#crossLink \"HtmlDataSource\"}}{{/crossLink}} is used.\r\n\t\t *\r\n\t\t * @property renderer\r\n\t\t * @type {AbstractRenderer|array}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.dataSource = null;\r\n\r\n\t\t/**\r\n\t\t * Optional custom renderer to use.\r\n\t\t *\r\n\t\t * If none is provided then the {{#crossLink \"HtmlRenderer\"}}{{/crossLink}} is used.\r\n\t\t *\r\n\t\t * @property renderer\r\n\t\t * @type {AbstractRenderer}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.renderer = null;\r\n\r\n\t\t/**\r\n\t\t * Optional custom animator to use.\r\n\t\t *\r\n\t\t * Should be an instance of {{#crossLink \"AbstractAnimator\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * If none is provided then the {{#crossLink \"DefaultAnimator\"}}{{/crossLink}} is used.\r\n\t\t *\r\n\t\t * @property animator\r\n\t\t * @type {AbstractAnimator}\r\n\t\t * @default null\r\n\t\t */\r\n\t\tthis.animator = null;\r\n\r\n\t\t/**\r\n\t\t * Returns the range of items that should be rendered given current item index and items per page.\r\n\t\t *\r\n\t\t * By default returns one page before the current page and one after but one may choose to override it.\r\n\t\t *\r\n\t\t * @method getRenderRange\r\n\t\t * @param {number} currentItemIndex Currently scrolled position index\r\n\t\t * @param {number} itemsPerPage How many items are shown on a page\r\n\t\t * @param {number} itemCount How many items there are in total\r\n\t\t * @return {object} Render range with start and end keys\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis.getRenderRange = function(currentItemIndex, itemsPerPage, itemCount) {\r\n\t\t\treturn {\r\n\t\t\t\tstart: Math.max(currentItemIndex - itemsPerPage, 0),\r\n\t\t\t\tend: Math.min(currentItemIndex + itemsPerPage * 2 - 1, itemCount - 1)\r\n\t\t\t};\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Enumeration of possible carousel orientations.\r\n\t *\r\n\t * @property Orientation\r\n\t * @type {object}\r\n\t * @param {string} Orientation.HORIZONTAL='horizontal' Horizontal orientation\r\n\t * @param {string} Orientation.VERTIAL='vertical' Vertical orientation\r\n\t * @static\r\n\t */\r\n\tConfig.Orientation = {\r\n\t\tHORIZONTAL: 'horizontal',\r\n\t\tVERTICAL: 'vertical'\r\n\t};\r\n\r\n\t/**\r\n\t * There are two different strategies for setting the size of the wrap and the items:\r\n\t * > MATCH_WRAP - the size of the items is set to match the wrap size\r\n\t * > MATCH_LARGEST_ITEM - the size of the wrap is set to match the largest item\r\n\t *\r\n\t * @property SizeMode\r\n\t * @type {object}\r\n\t * @param {string} Orientation.MATCH_WRAP='match-wrap' Items size is based on wrap size\r\n\t * @param {string} Orientation.MATCH_LARGEST_ITEM='match-largest-item' Wrap size is based on items size\r\n\t * @static\r\n\t */\r\n\tConfig.SizeMode = {\r\n\t\tMATCH_WRAP: 'match-wrap',\r\n\t\tMATCH_LARGEST_ITEM: 'match-largest-item'\r\n\t};\r\n\r\n\t/**\r\n\t * Extends the base default configuration properties with user-defined values.\r\n\t *\r\n\t * Performs a deep-extend.\r\n\t *\r\n\t * @method extend\r\n\t * @param {object} userConfig\r\n\t */\r\n\tConfig.prototype.extend = function(userConfig) {\r\n\t\t$.extend(true, this, userConfig);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of items to render side-by-side based on the wrap size and\r\n\t * {{#crossLink \"Config/responsiveBreakpoints:property\"}}{{/crossLink}} setting.\r\n\t *\r\n\t * @method getItemsPerPage\r\n\t * @param {number} wrapSize Wrap size to base the calculation on\r\n\t */\r\n\tConfig.prototype.getItemsPerPage = function(wrapSize) {\r\n\t\tvar i,\r\n\t\t\tbreakpoint;\r\n\r\n\t\tif (!this.useResponsiveLayout) {\r\n\t\t\treturn this.itemsPerPage;\r\n\t\t}\r\n\r\n\t\t// TODO could be cached\r\n\t\tfor (i = this.responsiveBreakpoints.length - 1; i >= 0; i--) {\r\n\t\t\tbreakpoint = this.responsiveBreakpoints[i];\r\n\r\n\t\t\tif (breakpoint.size <= wrapSize) {\r\n\t\t\t\treturn breakpoint.itemsPerPage;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.responsiveBreakpoints[0].itemsPerPage;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns class name to use by type.\r\n\t *\r\n\t * The class name is constructed by combining the value of {{#crossLink \"Config/cssPrefix:property\"}}{{/crossLink}}\r\n\t * and the mapping in {{#crossLink \"Config/cssClasses:property\"}}{{/crossLink}}.\r\n\t *\r\n\t * Throws error if invalid class name type is requested.\r\n\t *\r\n\t * @method getClassName\r\n\t * @param {string} type Class name type, one of the keys in cssClasses\r\n\t * @return {string}\r\n\t */\r\n\tConfig.prototype.getClassName = function(type) {\r\n\t\tif (typeof(this.cssClasses[type]) === 'undefined') {\r\n\t\t\tthrow new Error('Unknown CSS class type \"' + type + '\" requested');\r\n\t\t}\r\n\r\n\t\treturn this.cssPrefix + this.cssClasses[type];\r\n\t};\r\n\r\n\treturn Config;\r\n});\n","define('AbstractDataSource',[\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Data source interface.\r\n\t *\r\n\t * @class AbstractDataSource\r\n\t * @constructor\r\n\t */\r\n\tfunction AbstractDataSource() {}\r\n\r\n\t/**\r\n\t * Returns the number of items in the dataset.\r\n\t *\r\n\t * @method getItemCount\r\n\t * @return {number}\r\n\t */\r\n\tAbstractDataSource.prototype.getItemCount = function() {\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether given data source is asynchronous or not.\r\n\t *\r\n\t * If the data source is asynchronous then placeholders are generated by default while the real data is loading.\r\n\t *\r\n\t * Defaults to false so make sure to override this in your async data sources.\r\n\t *\r\n\t * @method isAsynchronous\r\n\t * @return {boolean}\r\n\t */\r\n\tAbstractDataSource.prototype.isAsynchronous = function() {\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Fetches given range of items from the dataset.\r\n\t *\r\n\t * This operation can be asynchronous and thus returns a promise that will be resolved once the data becomes\r\n\t * available or rejected when an error occurs.\r\n\t *\r\n\t * By default the range is the entire dataset.\r\n\t *\r\n\t * Throws error if invalid range is requested.\r\n\t *\r\n\t * @method getItems\r\n\t * @param {number} [startIndex=0] Range start index to fetch\r\n\t * @param {number} [endIndex=length] Range end index to fetch\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tAbstractDataSource.prototype.getItems = function(startIndex, endIndex) {\r\n\t\tvoid(startIndex, endIndex);\r\n\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tAbstractDataSource.prototype.destroy = function() {\r\n\t\t// do nothing by default\r\n\t};\r\n\r\n\treturn AbstractDataSource;\r\n});\n","define('ArrayDataSource',[\r\n\t'AbstractDataSource',\r\n\t'Deferred'\r\n], function(AbstractDataSource, Deferred) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Data source interface.\r\n\t *\r\n\t * @class ArrayDataSource\r\n\t * @extends AbstractDataSource\r\n\t * @constructor\r\n\t */\r\n\tfunction ArrayDataSource(data) {\r\n\t\tAbstractDataSource.call(this);\r\n\r\n\t\tthis._data = data || [];\r\n\t}\r\n\r\n\tArrayDataSource.prototype = Object.create(AbstractDataSource.prototype);\r\n\r\n\t/**\r\n\t * Sets new data to use.\r\n\t *\r\n\t * @method setData\r\n\t * @param {array} data New data\r\n\t */\r\n\tArrayDataSource.prototype.setData = function(data) {\r\n\t\tthis._data = data;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of items in the dataset.\r\n\t *\r\n\t * @method getItemCount\r\n\t * @return {number}\r\n\t */\r\n\tArrayDataSource.prototype.getItemCount = function() {\r\n\t\treturn this._data.length;\r\n\t};\r\n\r\n\t/**\r\n\t * Fetches given range of items from the dataset.\r\n\t *\r\n\t * This operation can be asynchronous and thus returns a promise that will be resolved once the data becomes\r\n\t * available or rejected when an error occurs.\r\n\t *\r\n\t * By default the range is the entire dataset.\r\n\t *\r\n\t * Throws error if invalid range is requested.\r\n\t *\r\n\t * @method getItems\r\n\t * @param {number} [startIndex=0] Range start index to fetch\r\n\t * @param {number} [endIndex=length] Range end index to fetch\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tArrayDataSource.prototype.getItems = function(startIndex, endIndex) {\r\n\t\tvar deferred = new Deferred();\r\n\r\n\t\tstartIndex = typeof startIndex === 'number' ? startIndex : 0;\r\n\t\tendIndex = typeof endIndex === 'number' ? endIndex : this._data.length - 1;\r\n\r\n\t\t// validate index range\r\n\t\tif (startIndex < 0) {\r\n\t\t\tthrow new Error('Invalid negative start index \"' + startIndex + '\" requested');\r\n\t\t} else if (endIndex > this._data.length - 1) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Too large end index \"' + endIndex + '\" requested, there are only ' + this._data.length + ' items'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// resolve the deferred immediately as array data source is syncronous\r\n\t\tdeferred.resolve(this._data.slice(startIndex, endIndex + 1));\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\treturn ArrayDataSource;\r\n});\n","define('HtmlDataSource',[\r\n\t'jquery',\r\n\t'AbstractDataSource',\r\n\t'Deferred'\r\n], function($, AbstractDataSource, Deferred) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Data source interface.\r\n\t *\r\n\t * @class HtmlDataSource\r\n\t * @extends AbstractDataSource\r\n\t * @constructor\r\n\t */\r\n\tfunction HtmlDataSource(wrap) {\r\n\t\tAbstractDataSource.call(this);\r\n\r\n\t\tthis._wrap = wrap;\r\n\t\tthis._data = this._setupData(this._wrap);\r\n\t}\r\n\r\n\tHtmlDataSource.prototype = Object.create(AbstractDataSource.prototype);\r\n\r\n\t/**\r\n\t * Returns the number of items in the dataset.\r\n\t *\r\n\t * @method getItemCount\r\n\t * @return {number}\r\n\t */\r\n\tHtmlDataSource.prototype.getItemCount = function() {\r\n\t\treturn this._data.length;\r\n\t};\r\n\r\n\t/**\r\n\t * Fetches given range of items from the dataset.\r\n\t *\r\n\t * This operation can be asynchronous and thus returns a promise that will be resolved once the data becomes\r\n\t * available or rejected when an error occurs.\r\n\t *\r\n\t * By default the range is the entire dataset.\r\n\t *\r\n\t * Throws error if invalid range is requested.\r\n\t *\r\n\t * @method getItems\r\n\t * @param {number} [startIndex=0] Range start index to fetch\r\n\t * @param {number} [endIndex=length] Range end index to fetch\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tHtmlDataSource.prototype.getItems = function(startIndex, endIndex) {\r\n\t\tvar deferred = new Deferred();\r\n\r\n\t\tstartIndex = typeof startIndex === 'number' ? startIndex : 0;\r\n\t\tendIndex = typeof endIndex === 'number' ? endIndex : this._data.length - 1;\r\n\r\n\t\t// validate index range\r\n\t\tif (startIndex < 0) {\r\n\t\t\tthrow new Error('Invalid negative start index \"' + startIndex + '\" requested');\r\n\t\t} else if (endIndex > this._data.length - 1) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Too large end index \"' + endIndex + '\" requested, there are only ' + this._data.length + ' items'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// resolve the deferred immediately as array data source is syncronous\r\n\t\tdeferred.resolve(this._data.slice(startIndex, endIndex + 1));\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Extracts the HTML item elements from the given wrap and uses them as data.\r\n\t *\r\n\t * @method _setupData\r\n\t * @param {DOMElement} wrap Wrap to get items from\r\n\t * @return {array}\r\n\t */\r\n\tHtmlDataSource.prototype._setupData = function(wrap) {\r\n\t\tvar elements = [];\r\n\r\n\t\t$(wrap).children().each(function(index, element) {\r\n\t\t\telements.push(element);\r\n\r\n\t\t\t// detach the original element from the dom\r\n\t\t\t$(element).detach();\r\n\t\t});\r\n\r\n\t\treturn elements;\r\n\t};\r\n\r\n\treturn HtmlDataSource;\r\n});\n","define('AbstractAnimator',[\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Animator interface.\r\n\t *\r\n\t * @class AbstractAnimator\r\n\t * @constructor\r\n\t * @param {FlowCarousel} carousel The carousel component\r\n\t */\r\n\tfunction AbstractAnimator(carousel) {\r\n\t\tvoid(carousel);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns current absolute position.\r\n\t *\r\n\t * @method getCurrentPosition\r\n\t * @return {number}\r\n\t */\r\n\tAbstractAnimator.prototype.getCurrentPosition = function() {\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Animates the carousel to given item index position.\r\n\t *\r\n\t * @method animateToItem\r\n\t * @param {number} itemIndex Index of the item\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tAbstractAnimator.prototype.animateToItem = function(itemIndex, instant) {\r\n\t\tvoid(itemIndex, instant);\r\n\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Animates the carousel to given absolute position.\r\n\t *\r\n\t * @method animateToPosition\r\n\t * @param {number} position Requested position\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @param {boolean} [noDeferred=false] Does not create a deferred if set to true\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tAbstractAnimator.prototype.animateToPosition = function(position, instant, noDeferred) {\r\n\t\tvoid(position, instant, noDeferred);\r\n\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel once it's structure has been initiated.\r\n\t *\r\n\t * @method onCarouselElementReady\r\n\t */\r\n\tAbstractAnimator.prototype.onCarouselElementReady = function() {\r\n\t\t// do nothing by default\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tAbstractAnimator.prototype.destroy = function() {\r\n\t\t// do nothing by default\r\n\t};\r\n\r\n\treturn AbstractAnimator;\r\n});\n","define('DefaultAnimator',[\r\n\t'jquery',\r\n\t'AbstractAnimator',\r\n\t'Config',\r\n\t'Util',\r\n\t'Deferred'\r\n], function($, AbstractAnimator, Config, Util, Deferred) {\r\n\t'use strict';\r\n\r\n\t// requestAnimationFrame polyfill\r\n\t(function () {\r\n\t\tvar lastTime = 0,\r\n\t\t\tvendors = ['webkit', 'moz'],\r\n\t\t\tx;\r\n\r\n\t\tfor (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n\t\t\twindow.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n\r\n\t\t\twindow.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']\r\n\t\t\t\t|| window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n\t\t}\r\n\r\n\t\tif (!window.requestAnimationFrame) {\r\n\t\t\twindow.requestAnimationFrame = function(callback/*, element*/) {\r\n\t\t\t\tvar currTime = new Date().getTime(),\r\n\t\t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime)),\r\n\t\t\t\t\tid = window.setTimeout(function () {\r\n\t\t\t\t\t\tcallback(currTime + timeToCall);\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttimeToCall);\r\n\r\n\t\t\t\tlastTime = currTime + timeToCall;\r\n\r\n\t\t\t\treturn id;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (!window.cancelAnimationFrame) {\r\n\t\t\twindow.cancelAnimationFrame = function(id) {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t};\r\n\t\t}\r\n\t}());\r\n\r\n\t/**\r\n\t * Data source interface.\r\n\t *\r\n\t * @class DefaultAnimator\r\n\t * @extends AbstractAnimator\r\n\t * @constructor\r\n\t * @param {FlowCarousel} carousel The carousel component\r\n\t */\r\n\tfunction DefaultAnimator(carousel) {\r\n\t\tAbstractAnimator.call(this, carousel);\r\n\r\n\t\tthis._carousel = carousel;\r\n\t\tthis._activeDeferred = null;\r\n\t\tthis._transitionEndListenerCreated = false;\r\n\t\tthis._eventListeners = {\r\n\t\t\ttransitionEnd: this._onRawTransitionEnd.bind(this)\r\n\t\t};\r\n\t}\r\n\r\n\tDefaultAnimator.prototype = Object.create(AbstractAnimator.prototype);\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tAbstractAnimator.prototype.destroy = function() {\r\n\t\tvar $scrollerWrap = $(this._carousel.getScrollerWrap());\r\n\r\n\t\t// remove the transition end listener\r\n\t\t$scrollerWrap.off(\r\n\t\t\t'transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd',\r\n\t\t\tthis._eventListeners.transitionEnd\r\n\t\t);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current absolute position.\r\n\t *\r\n\t * @method getCurrentPosition\r\n\t * @return {number}\r\n\t */\r\n\tDefaultAnimator.prototype.getCurrentPosition = function() {\r\n\t\tvar $scrollerWrap = $(this._carousel.getScrollerWrap()),\r\n\t\t\ttransformMatrix = $scrollerWrap.css('transform'),\r\n\t\t\ttransformOffset = Util.parseTransformMatrix(transformMatrix),\r\n\t\t\torientation = this._carousel.getOrientation();\r\n\r\n\t\tif (orientation === Config.Orientation.HORIZONTAL) {\r\n\t\t\treturn transformOffset.x;\r\n\t\t} else {\r\n\t\t\treturn transformOffset.y;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Animates the carousel to given item index position.\r\n\t *\r\n\t * @method animateToItem\r\n\t * @param {number} itemIndex Index of the item\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tDefaultAnimator.prototype.animateToItem = function(itemIndex, instant) {\r\n\t\tvar position = this._carousel.getItemPositionByIndex(itemIndex);\r\n\r\n\t\treturn this.animateToPosition(position, instant);\r\n\t};\r\n\r\n\t/**\r\n\t * Animates the carousel to given absolute position.\r\n\t *\r\n\t * @method animateToPosition\r\n\t * @param {number} position Requested position\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @param {boolean} [noDeferred=false] Does not create a deferred if set to true\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tDefaultAnimator.prototype.animateToPosition = function(position, instant, noDeferred) {\r\n\t\tinstant = typeof instant === 'boolean' ? instant : false;\r\n\t\tnoDeferred = typeof noDeferred === 'boolean' ? noDeferred : false;\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (!this._transitionEndListenerCreated && instant !== true) {\r\n\t\t\tthrow new Error('Requested non-instant animation before transition end listener was created');\r\n\t\t}\r\n\r\n\t\tvar deferred = noDeferred ? null : new Deferred(),\r\n\t\t\torientation = this._carousel.getOrientation(),\r\n\t\t\t$scrollerWrap = $(this._carousel.getScrollerWrap()),\r\n\t\t\tanimateTransformClass = this._carousel.getConfig().getClassName('animateTransform'),\r\n\t\t\tcurrentPosition,\r\n\t\t\ttranslateCommand;\r\n\r\n\t\t// make sure the position is a full integer\r\n\t\tposition = Math.floor(position);\r\n\r\n\t\t// resolve existing deferred if exists\r\n\t\t/* istanbul ignore if */\r\n\t\tif (this._activeDeferred !== null) {\r\n\t\t\tthis._activeDeferred.resolve();\r\n\t\t\tthis._activeDeferred = null;\r\n\t\t}\r\n\r\n\t\t// don't waste power on current position if not using deferred\r\n\t\tif (noDeferred !== true) {\r\n\t\t\tcurrentPosition = this.getCurrentPosition();\r\n\t\t}\r\n\r\n\t\t// the translate command is different for horizontal and vertical carousels\r\n\t\tif (orientation === Config.Orientation.HORIZONTAL) {\r\n\t\t\ttranslateCommand = 'translate3d(' + position + 'px,0,0)';\r\n\t\t} else {\r\n\t\t\ttranslateCommand = 'translate3d(0,' + position + 'px,0)';\r\n\t\t}\r\n\r\n\t\t// add a class that enables transitioning transforms if instant is not required\r\n\t\tif (instant === true && $scrollerWrap.hasClass(animateTransformClass)) {\r\n\t\t\t$scrollerWrap.removeClass(animateTransformClass);\r\n\t\t} else if (instant === false && !$scrollerWrap.hasClass(animateTransformClass)) {\r\n\t\t\t$scrollerWrap.addClass(animateTransformClass);\r\n\t\t}\r\n\r\n\t\t// apply the translate, use requestAnimationFrame for smoother results\r\n\t\twindow.requestAnimationFrame(function () {\r\n\t\t\t$scrollerWrap.css('transform', translateCommand);\r\n\t\t});\r\n\r\n\t\t//$scrollerWrap.css('transform', translateCommand);\r\n\r\n\t\t// remove the deferred overhead where not required\r\n\t\tif (noDeferred) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if the position is same as current then resolve immediately\r\n\t\tif (instant || (noDeferred !== true && position === currentPosition)) {\r\n\t\t\tdeferred.resolve();\r\n\t\t} else {\r\n\t\t\tthis._activeDeferred = new Deferred();\r\n\r\n\t\t\tthis._activeDeferred.done(function() {\r\n\t\t\t\tthis._activeDeferred = null;\r\n\r\n\t\t\t\tdeferred.resolve();\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel once it's structure has been initiated.\r\n\t *\r\n\t * @method onCarouselInitiated\r\n\t */\r\n\tDefaultAnimator.prototype.onCarouselElementReady = function() {\r\n\t\tthis._setupTransitionEndListener();\r\n\t};\r\n\r\n\t/**\r\n\t * Starts listening for transition end event on the scroller wrap.\r\n\t *\r\n\t * @method _setupTransitionEndListener\r\n\t * @private\r\n\t */\r\n\tDefaultAnimator.prototype._setupTransitionEndListener = function() {\r\n\t\tvar $scrollerWrap = $(this._carousel.getScrollerWrap());\r\n\r\n\t\t$scrollerWrap.on(\r\n\t\t\t'transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd',\r\n\t\t\tthis._eventListeners.transitionEnd\r\n\t\t);\r\n\r\n\t\tthis._transitionEndListenerCreated = true;\r\n\t};\r\n\r\n\t/**\r\n\t * Called on transition end event.\r\n\t *\r\n\t * @method _onRawTransitionEnd\r\n\t * @param {Event} e Raw event\r\n\t * @private\r\n\t */\r\n\tDefaultAnimator.prototype._onRawTransitionEnd = function(/*e*/) {\r\n\t\t// resolve the active deferred if exists\r\n\t\tthis._resolveDeferred();\r\n\t};\r\n\r\n\t/**\r\n\t * Resolves currently active deferred if available and sets it to null.\r\n\t *\r\n\t * @method _resolveDeferred\r\n\t * @private\r\n\t */\r\n\tDefaultAnimator.prototype._resolveDeferred = function() {\r\n\t\tif (this._activeDeferred === null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeDeferred.resolve();\r\n\t};\r\n\r\n\treturn DefaultAnimator;\r\n});\n","define('AbstractRenderer',[\r\n\t'jquery'\r\n], function($) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Abstract renderer base class.\r\n\t *\r\n\t * @class AbstractRenderer\r\n\t * @constructor\r\n\t */\r\n\tfunction AbstractRenderer() {}\r\n\r\n\t/**\r\n\t * Renders a carousel item.\r\n\t *\r\n\t * The data can be either a object of key-value pairs or an existing dom element to modify.\r\n\t *\r\n\t * Rendering an item can be asynchronous so a promise is returned.\r\n\t *\r\n\t * @method renderItem\r\n\t * @param {Config} config Carousel configuration\r\n\t * @param {number} index Item position index\r\n\t * @param {object|DOMElement} data Item data object or existing dom element\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tAbstractRenderer.prototype.renderItem = function(config, index, data) {\r\n\t\tvoid(config, index, data);\r\n\r\n\t\tthrow new Error('Not implemented');\r\n\t};\r\n\r\n\t/**\r\n\t * Renders a loading item placeholder.\r\n\t *\r\n\t * By default returns a simple div with the\r\n\t * {{#crossLink \"Config/cssClasses/placeholder:property\"}}{{/crossLink}} class.\r\n\t *\r\n\t * You may override this in your custom renderer.\r\n\t *\r\n\t * @method renderPlaceholder\r\n\t * @param {Config} config Carousel configuration\r\n\t * @param {number} index Item position index\r\n\t * @return {DOMElement}\r\n\t */\r\n\tAbstractRenderer.prototype.renderPlaceholder = function(config, index) {\r\n\t\tvoid(index);\r\n\r\n\t\treturn $('<div></div>')[0];\r\n\t};\r\n\r\n\t/**\r\n\t * Destroys a carousel item.\r\n\t *\r\n\t * By default just removes the element using jQuery, but inheriting classes may choose to do something fancier.\r\n\t *\r\n\t * @method destroyItem\r\n\t * @param {DOMElement} element DOM element to destroy\r\n\t */\r\n\tAbstractRenderer.prototype.destroyItem = function(element) {\r\n\t\t$(element).remove();\r\n\t};\r\n\r\n\t/**\r\n\t * Restores the initial contents of the carousel if possible.\r\n\t *\r\n\t * @method restoreInitialContents\r\n\t * @param {AbstractDataSource} dataSource Data source to use\r\n\t * @param {DOMElement} wrap Wrap to populate\r\n\t */\r\n\tAbstractRenderer.prototype.restoreInitialContents = function(dataSource, wrap) {\r\n\t\t// don't do anything by default\r\n\t\tvoid(dataSource, wrap);\r\n\t};\r\n\r\n\t/**\r\n\t * Called by the carousel on destroy.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tAbstractRenderer.prototype.destroy = function() {\r\n\t\t// do nothing by default\r\n\t};\r\n\r\n\treturn AbstractRenderer;\r\n});\n","define('HtmlRenderer',[\r\n\t'AbstractRenderer',\r\n\t'Deferred'\r\n], function(AbstractRenderer, Deferred) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * The default renderer for already existing HTML elements.\r\n\t *\r\n\t * @class HtmlRenderer\r\n\t * @extends AbstractRenderer\r\n\t * @constructor\r\n\t */\r\n\tfunction HtmlRenderer() {\r\n\t\tAbstractRenderer.call(this);\r\n\t}\r\n\r\n\tHtmlRenderer.prototype = Object.create(AbstractRenderer.prototype);\r\n\r\n\t/**\r\n\t * Renders a carousel item.\r\n\t *\r\n\t * The data can be either a object of key-value pairs or an existing dom element to modify.\r\n\t *\r\n\t * Rendering an item can be asynchronous so a promise is returned.\r\n\t *\r\n\t * The data is an already existing DOMElement for HtmlRenderer.\r\n\t *\r\n\t * @method renderItem\r\n\t * @param {Config} config Carousel configuration\r\n\t * @param {number} index Item position index\r\n\t * @param {object|DOMElement} element Item data object or existing dom element\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tHtmlRenderer.prototype.renderItem = function(config, index, element) {\r\n\t\tvar deferred = new Deferred();\r\n\r\n\t\t// html renderer is synchronous so resolve the promise immediately\r\n\t\tdeferred.resolve(element);\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Restores the initial contents of the carousel if possible.\r\n\t *\r\n\t * @method restoreInitialContents\r\n\t * @param {AbstractDataSource} dataSource Data source to use\r\n\t * @param {DOMElement} wrap Wrap to populate\r\n\t */\r\n\tHtmlRenderer.prototype.restoreInitialContents = function(dataSource, wrap) {\r\n\t\t// fetch all items and append them to the wrap\r\n\t\tdataSource.getItems().done(function(items) {\r\n\t\t\t$(items).each(function(index, element) {\r\n\t\t\t\tvar existingStyle = $(element).attr('style');\r\n\r\n\t\t\t\t// remove the added display: block\r\n\t\t\t\tif (typeof(existingStyle) === 'string') {\r\n\t\t\t\t\t$(element).attr('style', existingStyle.replace('display: block;', ''));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$(wrap).append(element);\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\treturn HtmlRenderer;\r\n});\n","/*!\n * EventEmitter v4.2.7 - git.io/ee\n * Oliver Caldwell\n * MIT license\n * @preserve\n */\n\n(function () {\n\t'use strict';\n\n\t/**\n\t * Class for managing events.\n\t * Can be extended to provide event functionality in other classes.\n\t *\n\t * @class EventEmitter Manages event registering and emitting.\n\t */\n\tfunction EventEmitter() {}\n\n\t// Shortcuts to improve speed and size\n\tvar proto = EventEmitter.prototype;\n\tvar exports = this;\n\tvar originalGlobalValue = exports.EventEmitter;\n\n\t/**\n\t * Finds the index of the listener for the event in it's storage array.\n\t *\n\t * @param {Function[]} listeners Array of listeners to search through.\n\t * @param {Function} listener Method to look for.\n\t * @return {Number} Index of the specified listener, -1 if not found\n\t * @api private\n\t */\n\tfunction indexOfListener(listeners, listener) {\n\t\tvar i = listeners.length;\n\t\twhile (i--) {\n\t\t\tif (listeners[i].listener === listener) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Alias a method while keeping the context correct, to allow for overwriting of target method.\n\t *\n\t * @param {String} name The name of the target method.\n\t * @return {Function} The aliased method\n\t * @api private\n\t */\n\tfunction alias(name) {\n\t\treturn function aliasClosure() {\n\t\t\treturn this[name].apply(this, arguments);\n\t\t};\n\t}\n\n\t/**\n\t * Returns the listener array for the specified event.\n\t * Will initialise the event object and listener arrays if required.\n\t * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n\t * Each property in the object response is an array of listener functions.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Function[]|Object} All listener functions for the event.\n\t */\n\tproto.getListeners = function getListeners(evt) {\n\t\tvar events = this._getEvents();\n\t\tvar response;\n\t\tvar key;\n\n\t\t// Return a concatenated array of all matching events if\n\t\t// the selector is a regular expression.\n\t\tif (evt instanceof RegExp) {\n\t\t\tresponse = {};\n\t\t\tfor (key in events) {\n\t\t\t\tif (events.hasOwnProperty(key) && evt.test(key)) {\n\t\t\t\t\tresponse[key] = events[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresponse = events[evt] || (events[evt] = []);\n\t\t}\n\n\t\treturn response;\n\t};\n\n\t/**\n\t * Takes a list of listener objects and flattens it into a list of listener functions.\n\t *\n\t * @param {Object[]} listeners Raw listener objects.\n\t * @return {Function[]} Just the listener functions.\n\t */\n\tproto.flattenListeners = function flattenListeners(listeners) {\n\t\tvar flatListeners = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < listeners.length; i += 1) {\n\t\t\tflatListeners.push(listeners[i].listener);\n\t\t}\n\n\t\treturn flatListeners;\n\t};\n\n\t/**\n\t * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n\t *\n\t * @param {String|RegExp} evt Name of the event to return the listeners from.\n\t * @return {Object} All listener functions for an event in an object.\n\t */\n\tproto.getListenersAsObject = function getListenersAsObject(evt) {\n\t\tvar listeners = this.getListeners(evt);\n\t\tvar response;\n\n\t\tif (listeners instanceof Array) {\n\t\t\tresponse = {};\n\t\t\tresponse[evt] = listeners;\n\t\t}\n\n\t\treturn response || listeners;\n\t};\n\n\t/**\n\t * Adds a listener function to the specified event.\n\t * The listener will not be added if it is a duplicate.\n\t * If the listener returns true then it will be removed after it is called.\n\t * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListener = function addListener(evt, listener) {\n\t\tvar listeners = this.getListenersAsObject(evt);\n\t\tvar listenerIsWrapped = typeof listener === 'object';\n\t\tvar key;\n\n\t\tfor (key in listeners) {\n\t\t\tif (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n\t\t\t\tlisteners[key].push(listenerIsWrapped ? listener : {\n\t\t\t\t\tlistener: listener,\n\t\t\t\t\tonce: false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Alias of addListener\n\t */\n\tproto.on = alias('addListener');\n\n\t/**\n\t * Semi-alias of addListener. It will add a listener that will be\n\t * automatically removed after it's first execution.\n\t *\n\t * @param {String|RegExp} evt Name of the event to attach the listener to.\n\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addOnceListener = function addOnceListener(evt, listener) {\n\t\treturn this.addListener(evt, {\n\t\t\tlistener: listener,\n\t\t\tonce: true\n\t\t});\n\t};\n\n\t/**\n\t * Alias of addOnceListener.\n\t */\n\tproto.once = alias('addOnceListener');\n\n\t/**\n\t * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n\t * You need to tell it what event names should be matched by a regex.\n\t *\n\t * @param {String} evt Name of the event to create.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvent = function defineEvent(evt) {\n\t\tthis.getListeners(evt);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Uses defineEvent to define multiple events.\n\t *\n\t * @param {String[]} evts An array of event names to define.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.defineEvents = function defineEvents(evts) {\n\t\tfor (var i = 0; i < evts.length; i += 1) {\n\t\t\tthis.defineEvent(evts[i]);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Removes a listener function from the specified event.\n\t * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to remove the listener from.\n\t * @param {Function} listener Method to remove from the event.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListener = function removeListener(evt, listener) {\n\t\tvar listeners = this.getListenersAsObject(evt);\n\t\tvar index;\n\t\tvar key;\n\n\t\tfor (key in listeners) {\n\t\t\tif (listeners.hasOwnProperty(key)) {\n\t\t\t\tindex = indexOfListener(listeners[key], listener);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlisteners[key].splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Alias of removeListener\n\t */\n\tproto.off = alias('removeListener');\n\n\t/**\n\t * Adds listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n\t * You can also pass it a regular expression to add the array of listeners to all events that match it.\n\t * Yeah, this function does quite a bit. That's probably a bad thing.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.addListeners = function addListeners(evt, listeners) {\n\t\t// Pass through to manipulateListeners\n\t\treturn this.manipulateListeners(false, evt, listeners);\n\t};\n\n\t/**\n\t * Removes listeners in bulk using the manipulateListeners method.\n\t * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be removed.\n\t * You can also pass it a regular expression to remove the listeners from all events that match it.\n\t *\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeListeners = function removeListeners(evt, listeners) {\n\t\t// Pass through to manipulateListeners\n\t\treturn this.manipulateListeners(true, evt, listeners);\n\t};\n\n\t/**\n\t * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n\t * The first argument will determine if the listeners are removed (true) or added (false).\n\t * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n\t * You can also pass it an event name and an array of listeners to be added/removed.\n\t * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n\t *\n\t * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n\t * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n\t\tvar i;\n\t\tvar value;\n\t\tvar single = remove ? this.removeListener : this.addListener;\n\t\tvar multiple = remove ? this.removeListeners : this.addListeners;\n\n\t\t// If evt is an object then pass each of it's properties to this method\n\t\tif (typeof evt === 'object' && !(evt instanceof RegExp)) {\n\t\t\tfor (i in evt) {\n\t\t\t\tif (evt.hasOwnProperty(i) && (value = evt[i])) {\n\t\t\t\t\t// Pass the single listener straight through to the singular method\n\t\t\t\t\tif (typeof value === 'function') {\n\t\t\t\t\t\tsingle.call(this, i, value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Otherwise pass back to the multiple function\n\t\t\t\t\t\tmultiple.call(this, i, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// So evt must be a string\n\t\t\t// And listeners must be an array of listeners\n\t\t\t// Loop over it and pass each one to the multiple method\n\t\t\ti = listeners.length;\n\t\t\twhile (i--) {\n\t\t\t\tsingle.call(this, evt, listeners[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Removes all listeners from a specified event.\n\t * If you do not specify an event then all listeners will be removed.\n\t * That means every event will be emptied.\n\t * You can also pass a regex to remove all events that match it.\n\t *\n\t * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.removeEvent = function removeEvent(evt) {\n\t\tvar type = typeof evt;\n\t\tvar events = this._getEvents();\n\t\tvar key;\n\n\t\t// Remove different things depending on the state of evt\n\t\tif (type === 'string') {\n\t\t\t// Remove all listeners for the specified event\n\t\t\tdelete events[evt];\n\t\t}\n\t\telse if (evt instanceof RegExp) {\n\t\t\t// Remove all events matching the regex.\n\t\t\tfor (key in events) {\n\t\t\t\tif (events.hasOwnProperty(key) && evt.test(key)) {\n\t\t\t\t\tdelete events[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Remove all listeners in all events\n\t\t\tdelete this._events;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Alias of removeEvent.\n\t *\n\t * Added to mirror the node API.\n\t */\n\tproto.removeAllListeners = alias('removeEvent');\n\n\t/**\n\t * Emits an event of your choice.\n\t * When emitted, every listener attached to that event will be executed.\n\t * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n\t * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n\t * So they will not arrive within the array on the other side, they will be separate.\n\t * You can also pass a regular expression to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {Array} [args] Optional array of arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emitEvent = function emitEvent(evt, args) {\n\t\tvar listeners = this.getListenersAsObject(evt);\n\t\tvar listener;\n\t\tvar i;\n\t\tvar key;\n\t\tvar response;\n\n\t\tfor (key in listeners) {\n\t\t\tif (listeners.hasOwnProperty(key)) {\n\t\t\t\ti = listeners[key].length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\t// If the listener returns true then it shall be removed from the event\n\t\t\t\t\t// The function is executed either with a basic call or an apply if there is an args array\n\t\t\t\t\tlistener = listeners[key][i];\n\n\t\t\t\t\tif (listener.once === true) {\n\t\t\t\t\t\tthis.removeListener(evt, listener.listener);\n\t\t\t\t\t}\n\n\t\t\t\t\tresponse = listener.listener.apply(this, args || []);\n\n\t\t\t\t\tif (response === this._getOnceReturnValue()) {\n\t\t\t\t\t\tthis.removeListener(evt, listener.listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Alias of emitEvent\n\t */\n\tproto.trigger = alias('emitEvent');\n\n\t/**\n\t * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n\t * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n\t *\n\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n\t * @param {...*} Optional additional arguments to be passed to each listener.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.emit = function emit(evt) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\treturn this.emitEvent(evt, args);\n\t};\n\n\t/**\n\t * Sets the current value to check against when executing listeners. If a\n\t * listeners return value matches the one set here then it will be removed\n\t * after execution. This value defaults to true.\n\t *\n\t * @param {*} value The new value to check for when executing listeners.\n\t * @return {Object} Current instance of EventEmitter for chaining.\n\t */\n\tproto.setOnceReturnValue = function setOnceReturnValue(value) {\n\t\tthis._onceReturnValue = value;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Fetches the current value to check against when executing listeners. If\n\t * the listeners return value matches this one then it should be removed\n\t * automatically. It will return true by default.\n\t *\n\t * @return {*|Boolean} The current value to check for or the default, true.\n\t * @api private\n\t */\n\tproto._getOnceReturnValue = function _getOnceReturnValue() {\n\t\tif (this.hasOwnProperty('_onceReturnValue')) {\n\t\t\treturn this._onceReturnValue;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * Fetches the events object and creates one if required.\n\t *\n\t * @return {Object} The events storage object.\n\t * @api private\n\t */\n\tproto._getEvents = function _getEvents() {\n\t\treturn this._events || (this._events = {});\n\t};\n\n\t/**\n\t * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n\t *\n\t * @return {Function} Non conflicting EventEmitter class.\n\t */\n\tEventEmitter.noConflict = function noConflict() {\n\t\texports.EventEmitter = originalGlobalValue;\n\t\treturn EventEmitter;\n\t};\n\n\t// Expose the class either via AMD, CommonJS or the global object\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine('EventEmitter',[],function () {\n\t\t\treturn EventEmitter;\n\t\t});\n\t}\n\telse if (typeof module === 'object' && module.exports){\n\t\tmodule.exports = EventEmitter;\n\t}\n\telse {\n\t\tthis.EventEmitter = EventEmitter;\n\t}\n}.call(this));\n\n","define('Exporter',[\r\n], function() {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Returns a function that accepts the carousel component as parameter and registers it to various systems\r\n\t * such as RequireJS AMD and AngularJS module if possible.\r\n\t */\r\n\treturn {\r\n\t\texport: function (FlowCarousel) {\r\n\t\t\t// support require.js style AMD\r\n\t\t\tif (typeof window.define === 'function' && window.define.amd) {\r\n\t\t\t\twindow.define('FlowCarousel', [], function () {\r\n\t\t\t\t\treturn FlowCarousel;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// register AngularJS module\r\n\t\t\t/*if (typeof window.angular === 'object') {\r\n\t\t\t\twindow.angular.module('FlowCarousel', [])\r\n\t\t\t\t\t.factory('flowCarousel', function() {\r\n\t\t\t\t\t\treturn FlowCarousel;\r\n\t\t\t\t\t});\r\n\t\t\t}*/\r\n\r\n\t\t\t// register under window\r\n\t\t\twindow.FlowCarousel = FlowCarousel;\r\n\t\t}\r\n\t};\r\n});\n","define('FlowCarousel',[\r\n\t'jquery',\r\n\t'Config',\r\n\t'AbstractDataSource',\r\n\t'ArrayDataSource',\r\n\t'HtmlDataSource',\r\n\t'AbstractAnimator',\r\n\t'DefaultAnimator',\r\n\t'AbstractRenderer',\r\n\t'HtmlRenderer',\r\n\t'AbstractNavigator',\r\n\t'Deferred',\r\n\t'Util',\r\n\t'EventEmitter',\r\n\t'Exporter'\r\n], function(\r\n\t$,\r\n\tConfig,\r\n\tAbstractDataSource,\r\n\tArrayDataSource,\r\n\tHtmlDataSource,\r\n\tAbstractAnimator,\r\n\tDefaultAnimator,\r\n\tAbstractRenderer,\r\n\tHtmlRenderer,\r\n\tAbstractNavigator,\r\n\tDeferred,\r\n\tUtil,\r\n\tEventEmitter,\r\n\tExporter\r\n) {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * FlowCarousel main class.\r\n\t *\r\n\t * Responsive paginated high-performance HTML5 carousel with AngularJS support.\r\n\t *\r\n\t * https://github.com/kallaspriit/flow-carousel\r\n\t *\r\n\t * @class FlowCarousel\r\n\t * @extends EventEmitter\r\n\t * @constructor\r\n\t * @author Priit Kallas <priit@stagnationlab.com>\r\n\t * @copyright Stagnation Lab\r\n\t * @licence MIT\r\n\t */\r\n\tfunction FlowCarousel() {\r\n\t\t/**\r\n\t\t * Component version number.\r\n\t\t *\r\n\t\t * @property version\r\n\t\t * @type string\r\n\t\t */\r\n\t\tthis.version = '0.1.0';\r\n\r\n\t\t/**\r\n\t\t * The index of nth carousel was created (0 for first, 1 for next etc..).\r\n\t\t *\r\n\t\t * @property _id\r\n\t\t * @type {number}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._id = FlowCarousel.instanceCount;\r\n\r\n\t\t/**\r\n\t\t * Set to true once the component is initiated and to false once it's destroyed.\r\n\t\t *\r\n\t\t * @property _initiated\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._initiated = false;\r\n\r\n\t\t/**\r\n\t\t * Set to true once the component is destroyed, no methods are valid to call after this.\r\n\t\t *\r\n\t\t * @property _destroyed\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._destroyed = false;\r\n\r\n\t\t/**\r\n\t\t * Carousel configuration.\r\n\t\t *\r\n\t\t * @property _config\r\n\t\t * @type Config\r\n\t\t * @default Config\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._config = new Config();\r\n\r\n\t\t/**\r\n\t\t * Data source to use.\r\n\t\t *\r\n\t\t * Data source is only set when the carousel is initiated with data or it's set with\r\n\t\t * {{#crossLink \"FlowCarousel/setDataSource\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * @property _dataSource\r\n\t\t * @type {AbstractDataSource}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._dataSource = null;\r\n\r\n\t\t/**\r\n\t\t * Renderer used to render the data.\r\n\t\t *\r\n\t\t * @property _renderer\r\n\t\t * @type {AbstractRenderer}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._renderer = null;\r\n\r\n\t\t/**\r\n\t\t * Animator to use.\r\n\t\t *\r\n\t\t * @property _animator\r\n\t\t * @type {AbstractAnimator}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._animator = null;\r\n\r\n\t\t/**\r\n\t\t * Map of navigators used to navigate the component.\r\n\t\t *\r\n\t\t * Use the config to set built-in navigators to use or add a custom one using\r\n\t\t * {{#crossLink \"FlowCarousel/addNavigator\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * @type {AbstractNavigator[]}\r\n\t\t * @private\r\n\t\t * @default {}\r\n\t\t */\r\n\t\tthis._navigators = {};\r\n\r\n\t\t/**\r\n\t\t * The top wrap elements jQuery object.\r\n\t\t *\r\n\t\t * @property _mainWrap\r\n\t\t * @type {DOMElement}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._mainWrap = null;\r\n\r\n\t\t/**\r\n\t\t * Wrap for the items that contains the {{#crossLink \"FlowCarousel/_scrollerWrap:property\"}}{{/crossLink}}\r\n\t\t * which in turn contains the actual item wrappers and items.\r\n\t\t *\r\n\t\t * @property _itemsWrap\r\n\t\t * @type {DOMElement}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._itemsWrap = null;\r\n\r\n\t\t/**\r\n\t\t * This is the wrap that's animated on navigation and contains the carousel element wraps.\r\n\t\t *\r\n\t\t * @property _scrollerWrap\r\n\t\t * @type {DOMElement}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._scrollerWrap = null;\r\n\r\n\t\t/**\r\n\t\t * Is the carousel currently animating.\r\n\t\t *\r\n\t\t * @property _isAnimating\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._isAnimating = false;\r\n\r\n\t\t/**\r\n\t\t * Is the carousel currently being dragged.\r\n\t\t *\r\n\t\t * @property _isDragged\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._isDragged = false;\r\n\r\n\t\t/**\r\n\t\t * Target item position index.\r\n\t\t *\r\n\t\t * This is set when animating to an index is requested.\r\n\t\t *\r\n\t\t * @property _targetItemIndex\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._targetItemIndex = 0;\r\n\r\n\t\t/**\r\n\t\t * Current item position index.\r\n\t\t *\r\n\t\t * This is updated once the animation completes.\r\n\t\t *\r\n\t\t * @property _currentItemIndex\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._currentItemIndex = 0;\r\n\r\n\t\t/**\r\n\t\t * Item index of the last centered item.\r\n\t\t *\r\n\t\t * @property _lastCenterItemIndex\r\n\t\t * @type {number|null}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._lastCenterItemIndex = null;\r\n\r\n\t\t/**\r\n\t\t * Index of currently-hovered item or null if not hovering any items.\r\n\t\t *\r\n\t\t * @property _hoverItemIndex\r\n\t\t * @type {number|null}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._hoverItemIndex = null;\r\n\r\n\t\t/**\r\n\t\t * List of item indexes that have been rendered.\r\n\t\t *\r\n\t\t * @property _renderedItemIndexes\r\n\t\t * @type {array}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._renderedItemIndexes = [];\r\n\r\n\t\t/**\r\n\t\t * List of placeholder indexes that have been rendered.\r\n\t\t *\r\n\t\t * TODO consider getting rid of this index list\r\n\t\t *\r\n\t\t * @property _renderedPlaceholderIndexes\r\n\t\t * @type {array}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._renderedPlaceholderIndexes = [];\r\n\r\n\t\t/**\r\n\t\t * Mapping of renderer item indexes to their dom elements.\r\n\t\t *\r\n\t\t * @property _itemIndexToElementMap\r\n\t\t * @type {object}\r\n\t\t * @default {}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._itemIndexToElementMap = {};\r\n\r\n\t\t/**\r\n\t\t * Map of delayed tasks used by {{#crossLink \"FlowCarousel/_performDelayed\"}}{{/crossLink}}.\r\n\t\t *\r\n\t\t * @property _delayedTasks\r\n\t\t * @type {object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._delayedTasks = {};\r\n\r\n\t\t/**\r\n\t\t * The deferred promise to the currently loading itemset.\r\n\t\t *\r\n\t\t * @property _getItemsPromise\r\n\t\t * @type {Deferred.Promise|null}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._getItemsPromise = null;\r\n\r\n\t\t/**\r\n\t\t * The deferred promise to the current animation.\r\n\t\t *\r\n\t\t * Set to null if no animation is playing.\r\n\t\t *\r\n\t\t * @property _activeAnimationDeferred\r\n\t\t * @type {Deferred.Promise|null}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._activeAnimationDeferred = null;\r\n\r\n\t\t/**\r\n\t\t * Has the {{#crossLink \"FlowCarousel/Event/STARTUP_ITEMS_RENDERED:property\"}}{{/crossLink}} event bee emitted.\r\n\t\t *\r\n\t\t * @property _startupItemsRenderedEmitted\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._startupItemsRenderedEmitted = false;\r\n\r\n\t\t/**\r\n\t\t * The last obesrved largest child size.\r\n\t\t *\r\n\t\t * @property _lastLargestChildSize\r\n\t\t * @type {number|null}\r\n\t\t * @default null\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._lastLargestChildSize = null;\r\n\r\n\t\t/**\r\n\t\t * Various cached sizes and values that do not need to be always calculated.\r\n\t\t *\r\n\t\t * @property _cache\r\n\t\t * @type {object}\r\n\t\t * @param {number|null} wrapSize The cached main wrap size\r\n\t\t * @param {number|null} wrapOppositeSize The cached main wrap opposite size\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._cache = {\r\n\t\t\twrapSize: null,\r\n\t\t\twrapOppositeSize: null\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * List of event listeners bound to the FlowCarousel instance.\r\n\t\t *\r\n\t\t * @property _eventListeners\r\n\t\t * @type {object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._eventListeners = {\r\n\t\t\tonWindowResize: this._onWindowResize.bind(this)\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Empty clone of the cache used for resetting it.\r\n\t\t *\r\n\t\t * @property _emptyCache\r\n\t\t * @type {object}\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._emptyCache = Util.cloneObj(this._cache);\r\n\r\n\t\t/**\r\n\t\t * Should caches be used when possible.\r\n\t\t *\r\n\t\t * @property _useCache\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._useCache = true;\r\n\r\n\t\t/**\r\n\t\t * Reference to the Event list.\r\n\t\t *\r\n\t\t * Useful for when you have an instance of the carousel but no reference to the class.\r\n\t\t *\r\n\t\t * @property Event\r\n\t\t * @type FlowCarousel.Event\r\n\t\t */\r\n\t\tthis.Event = FlowCarousel.Event;\r\n\r\n\t\t/**\r\n\t\t * Reference to the Config class.\r\n\t\t *\r\n\t\t * Useful for when you have an instance of the carousel but no reference to the class.\r\n\t\t *\r\n\t\t * @property Config\r\n\t\t * @type FlowCarousel.Config\r\n\t\t */\r\n\t\tthis.Config = FlowCarousel.Config;\r\n\r\n\t\t// increment the instance count\r\n\t\tFlowCarousel.instanceCount++;\r\n\t}\r\n\r\n\tFlowCarousel.prototype = Object.create(EventEmitter.prototype);\r\n\r\n\t/**\r\n\t * Number of instances that have been created in total.\r\n\t *\r\n\t * @property instanceCount\r\n\t * @type {number}\r\n\t * @default 0\r\n\t * @static\r\n\t */\r\n\tFlowCarousel.instanceCount = 0;\r\n\r\n\t/**\r\n\t * Number of instances that are currently live meaning they have been initialized but not destroyed.\r\n\t *\r\n\t * @property liveCount\r\n\t * @type {number}\r\n\t * @default 0\r\n\t * @static\r\n\t */\r\n\tFlowCarousel.liveCount = 0;\r\n\r\n\t// The main FlowCarousel classes are referenced under the main FlowCarousel class so that only the main\r\n\t// class is registered in the global namespace.\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"Config\"}}{{/crossLink}} class.\r\n\t *\r\n\t * Useful to access the enumerations in the configuration class.\r\n\t *\r\n\t * @property Config\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.Config = Config;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"AbstractDataSource\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property AbstractDataSource\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.AbstractDataSource = AbstractDataSource;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"ArrayDataSource\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property ArrayDataSource\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.ArrayDataSource = ArrayDataSource;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"HtmlDataSource\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property HtmlDataSource\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.HtmlDataSource = HtmlDataSource;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"AbstractRenderer\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property AbstractRenderer\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.AbstractRenderer = AbstractRenderer;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"HtmlRenderer\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property HtmlRenderer\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.HtmlRenderer = HtmlRenderer;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"AbstractAnimator\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property AbstractAnimator\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.AbstractAnimator = AbstractAnimator;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"DefaultAnimator\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property DefaultAnimator\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.DefaultAnimator = DefaultAnimator;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"AbstractNavigator\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property AbstractNavigator\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.AbstractNavigator = AbstractNavigator;\r\n\r\n\t/**\r\n\t * Reference to the {{#crossLink \"Deferred\"}}{{/crossLink}} class.\r\n\t *\r\n\t * @property Deferred\r\n\t * @type {Config}\r\n\t */\r\n\tFlowCarousel.Deferred = Deferred;\r\n\r\n\t/**\r\n\t * Possible size modes used by {{#crossLink \"FlowCarousel/_getWrapSize\"}}{{/crossLink}}.\r\n\t *\r\n\t * @property SizeMode\r\n\t * @type {object}\r\n\t * @param {string} SizeMode.INNER='inner' Inner size\r\n\t * @param {string} SizeMode.OUTER='outer' Outer size\r\n\t * @private\r\n\t * @static\r\n\t */\r\n\tFlowCarousel.SizeMode = {\r\n\t\tINNER: 'inner',\r\n\t\tOUTER: 'outer'\r\n\t};\r\n\r\n\t/**\r\n\t * List of possible events emitted by the carousel.\r\n\t *\r\n\t * The event system uses the Wolfy87 EventEmitter implementation https://github.com/Wolfy87/EventEmitter.\r\n\t *\r\n\t * You can subscribe to events using carousel.addListener(carousel.Event.INITIATED, function() { ... }); etc\r\n\t *\r\n\t * The [startIndex, endIndex] syntax shows the parameters passed to the callback.\r\n\t *\r\n\t * @property Event\r\n\t * @param {string} Event.INITIATING='initiating' Emitted when starting initiation\r\n\t * @param {string} Event.INITIATED='initiated' Emitted after completing initiation\r\n\t * @param {string} Event.STARTUP_ITEMS_RENDERED='startup-items-rendered' Emitted after rendering the first data\r\n\t * @param {string} Event.LOADING_ITEMS='loading-items' [startIndex, endIndex, items] Emitted when starting to load a\r\n\t * \t\t\t\t   new set of items\r\n\t * @param {string} Event.LOADED_ITEMS='loaded-items' [startIndex, endIndex, items] Emitted when a new set of items\r\n\t * \t\t\t\t   was loaded\r\n\t * @param {string} Event.ABORTED_ITEMS='aborted-items' [startIndex, endIndex] Emitted when loading a range of items\r\n\t * \t\t\t\t   was aborted\r\n\t * @param {string} Event.RENDERED_ITEMS='rendered-items' [startIndex, endIndex, elements] Emitted when a new set of\r\n\t * \t\t\t\t   items was rendered\r\n\t * @param {string} Event.DESTROYED_ITEMS='destroyed-items' [itemIndexes] Emitted when a set of items was destroyed\r\n\t * @param {string} Event.NAVIGATING_TO_ITEM='navigating-to-item' [itemIndex, instant] Emitted when starting to\r\n\t * \t\t\t\t   navigate to a carousel item index\r\n\t * @param {string} Event.NAVIGATED_TO_ITEM='navigated-to-item' [itemIndex, instant] Emitted when finished\r\n\t * \t\t\t\t   navigate to a carousel item index including animation\r\n\t * @param {string} Event.NAVIGATING_TO_PAGE='navigating-to-page' [pageIndex, instant] Emitted when starting to\r\n\t * \t\t\t\t   navigate to a carousel item index\r\n\t * @param {string} Event.NAVIGATED_TO_PAGE='navigated-to-page' [pageIndex, instant] Emitted when finished\r\n\t * \t\t\t\t   navigate to a carousel item index including animation\r\n\t * @param {string} Event.LAYOUT_CHANGED='layout-changed' Emitted when the layout is re-calculated\r\n\t * @param {string} Event.DRAG_BEGIN='drag-begin' [startPosition, dragOppositePosition, carouselPosition] Emitted\r\n\t * \t\t\t\t   when the drag navigator begins to drag the scroller\r\n\t * @param {string} Event.DRAG_END='drag-end' [navigationMode, startPosition, endPosition, deltaDragPosition,\r\n\t * \t\t\t\t   closestIndex, direction, targetElement] Emitted when dragging stopped\r\n\t * @type {object}\r\n\t */\r\n\tFlowCarousel.Event = {\r\n\t\tINITIATING: 'initiating',\r\n\t\tINITIATED: 'initiated',\r\n\t\tSTARTUP_ITEMS_RENDERED: 'startup-items-rendered',\r\n\r\n\t\tLOADING_ITEMS: 'loading-items',\r\n\t\tLOADED_ITEMS: 'loaded-items',\r\n\r\n\t\tABORTED_ITEMS: 'aborted-items',\r\n\r\n\t\tRENDERED_ITEMS: 'rendered-items',\r\n\t\tDESTROYED_ITEMS: 'destroyed-items',\r\n\r\n\t\tNAVIGATING_TO_ITEM: 'navigating-to-item',\r\n\t\tNAVIGATED_TO_ITEM: 'navigated-to-item',\r\n\r\n\t\tNAVIGATING_TO_PAGE: 'navigating-to-page',\r\n\t\tNAVIGATED_TO_PAGE: 'navigated-to-page',\r\n\r\n\t\tLAYOUT_CHANGED: 'layout-changed',\r\n\r\n\t\tDRAG_BEGIN: 'drag-begin',\r\n\t\tDRAG_END: 'drag-end',\r\n\t};\r\n\r\n\t/**\r\n\t * Initializes the carousel component.\r\n\t *\r\n\t * Returns a promise that will be resolved once the carousel has been initiated.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.INITIATING at the start of the procedure\r\n\t * - FlowCarousel.Event.INITIATED after initiation but the initial data may not have loaded yet\r\n\t * - FlowCarousel.Event.STARTUP_ITEMS_RENDERED after the initial set of data has rendered\r\n\t *\r\n\t * @method init\r\n\t * @param {string|jQuery|DOMElement} element Element selector or jQuery reference or a dom element\r\n\t * @param {object} [userConfig] Optional user configuration object overriding defaults in the\r\n\t * \t\t\t\t\t\t\t\t{{#crossLink \"Config\"}}{{/crossLink}}.\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tFlowCarousel.prototype.init = function(element, userConfig) {\r\n\t\tvar deferred = new Deferred();\r\n\r\n\t\tif (this._initiated) {\r\n\t\t\tthrow new Error('The carousel is already initiated');\r\n\t\t}\r\n\r\n\t\tthis.emit(FlowCarousel.Event.INITIATING);\r\n\r\n\t\t// extend the config with user-provided values if available\r\n\t\tif (Util.isObject(userConfig)) {\r\n\t\t\tthis._config.extend(userConfig);\r\n\t\t}\r\n\r\n\t\t// initialize the wrap element that match given selector\r\n\t\tthis._setupElement(element);\r\n\r\n\t\t// use provided data source or a simple array if provided, use HtmlDataSource if nothing is provided\r\n\t\tif (this._config.dataSource instanceof AbstractDataSource || Util.isArray(this._config.dataSource)) {\r\n\t\t\tthis.setDataSource(this._config.dataSource);\r\n\t\t} else if (typeof this._config.dataSource !== 'undefined' && this._config.dataSource !== null) {\r\n\t\t\tthrow new Error('Unexpected data source type \"' + typeof this._config.dataSource + '\" provided');\r\n\t\t} else {\r\n\t\t\t// the data-source could have been set before init\r\n\t\t\tif (this._dataSource === null) {\r\n\t\t\t\tthis._dataSource = new HtmlDataSource(this._mainWrap);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// use custom renderer if provided or the HtmlRenderer if not\r\n\t\tif (this._config.renderer !== null) {\r\n\t\t\tif (this._config.renderer instanceof AbstractRenderer) {\r\n\t\t\t\tthis._renderer = this._config.renderer;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Custom renderer provided in config but it\\'s not an instance of AbstractRenderer');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (this._dataSource instanceof HtmlDataSource) {\r\n\t\t\t\tthis._renderer = new HtmlRenderer();\r\n\t\t\t} else if (this._renderer === null) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t'Expecting a custom \"renderer\" to be defined in the config if not using the HtmlDataSource'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// use custom animator if provided or the DefaultAnimator if not\r\n\t\tif (this._config.animator !== null) {\r\n\t\t\tif (this._config.animator instanceof AbstractAnimator) {\r\n\t\t\t\tthis._animator = this._config.animator;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Custom animator provided in config but it\\'s not an instance of AbstractAnimator');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// the animator could have been set before init\r\n\t\t\tif (this._animator === null) {\r\n\t\t\t\tthis._animator = new DefaultAnimator(this);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// setup the carousel rendering and events\r\n\t\tthis._setupCarousel(this._mainWrap, this._config.orientation);\r\n\r\n\t\t// setup the default navigators\r\n\t\tthis._setupDefaultNavigators();\r\n\r\n\t\t// notify the animator that carousel is initiated\r\n\t\tthis._initiated = true;\r\n\r\n\t\t// increment the livecount\r\n\t\tFlowCarousel.liveCount++;\r\n\r\n\t\tthis.emit(FlowCarousel.Event.INITIATED);\r\n\r\n\t\tthis._validateItemsToRender().done(function() {\r\n\t\t\tthis.validateSize();\r\n\r\n\t\t\tdeferred.resolve();\r\n\t\t}.bind(this));\r\n\r\n\t\t// listen for wrap size changes and perform re-layout when needed once the carousel is initiated\r\n\t\tdeferred.done(function() {\r\n\t\t\tthis._setupWindowResizeListener();\r\n\t\t}.bind(this));\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Destroys the carousel component.\r\n\t *\r\n\t * @method destroy\r\n\t */\r\n\tFlowCarousel.prototype.destroy = function() {\r\n\t\tvar preservedMethodNames = ['isInitiated', 'isDestroyed'],\r\n\t\t\tnavigatorName,\r\n\t\t\tpropertyName;\r\n\r\n\t\tif (!this._initiated) {\r\n\t\t\tthrow new Error('Unable to destroy carousel that has not been initiated');\r\n\t\t}\r\n\r\n\t\t// destroy the sub-components\r\n\t\tif (this._dataSource instanceof AbstractDataSource) { this._dataSource.destroy(); }\r\n\t\tif (this._renderer instanceof AbstractRenderer) { this._renderer.destroy(); }\r\n\t\tif (this._animator instanceof AbstractAnimator) { this._animator.destroy(); }\r\n\r\n\t\t// destroy navigators\r\n\t\tfor (navigatorName in this._navigators) {\r\n\t\t\tif (this._navigators[navigatorName] instanceof AbstractNavigator) {\r\n\t\t\t\tthis._navigators[navigatorName].destroy();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// remove the carousel classes from the main wrap\r\n\t\tUtil.removeElementClassesPrefixedWith(this._mainWrap, this._config.cssPrefix);\r\n\r\n\t\t// clear the generated contents\r\n\t\t$(this._mainWrap).empty();\r\n\r\n\t\t// ask the renderer to restore the initial contents using the current data-source\r\n\t\tthis._renderer.restoreInitialContents(this._dataSource, this._mainWrap);\r\n\r\n\t\t// remove the data reference\r\n\t\t$(this._mainWrap).data(this._config.dataTarget, null);\r\n\r\n\t\t// remove the window resize listener\r\n\t\t$(window).off('resize', this._eventListeners.onWindowResize);\r\n\r\n\t\t// clear references and state\r\n\t\tthis._config = null;\r\n\t\tthis._dataSource = null;\r\n\t\tthis._renderer = null;\r\n\t\tthis._animator = null;\r\n\t\tthis._navigators = {};\r\n\t\tthis._mainWrap = null;\r\n\t\tthis._itemsWrap = null;\r\n\t\tthis._scrollerWrap = null;\r\n\t\tthis._isAnimating = false;\r\n\t\tthis._targetItemIndex = 0;\r\n\t\tthis._currentItemIndex = 0;\r\n\t\tthis._hoverItemIndex = null;\r\n\t\tthis._renderedItemIndexes = [];\r\n\t\tthis._renderedPlaceholderIndexes = [];\r\n\t\tthis._itemIndexToElementMap = {};\r\n\t\tthis._delayedTasks = {};\r\n\t\tthis._getItemsPromise = null;\r\n\t\tthis._activeAnimationDeferred = null;\r\n\t\tthis._startupItemsRenderedEmitted = false;\r\n\t\tthis._lastLargestChildSize = null;\r\n\t\tthis._cache = Util.cloneObj(this._emptyCache);\r\n\t\tthis._useCache = true;\r\n\r\n\t\t// disable all methods\r\n\t\tfor (propertyName in this) {\r\n\t\t\t// preserve some methods\r\n\t\t\tif (preservedMethodNames.indexOf(propertyName) !== -1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof this[propertyName] === 'function') {\r\n\t\t\t\tthis[propertyName] = function() {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'The carousel is destroyed, attempting to call any of its methods results in an error (' +\r\n\t\t\t\t\t\t'tried to call \"' + this.name + '\")'\r\n\t\t\t\t\t);\r\n\t\t\t\t}.bind({name: propertyName});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// mark the component destroyed\r\n\t\tthis._initiated = false;\r\n\t\tthis._destroyed = true;\r\n\r\n\t\t// decrement the livecount\r\n\t\tFlowCarousel.liveCount--;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the unique id and carousel index.\r\n\t *\r\n\t * @method getId\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getId = function() {\r\n\t\treturn this._id;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether the carousel has been initiated.\r\n\t *\r\n\t * @method isInitiated\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isInitiated = function() {\r\n\t\treturn this._initiated;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether the carousel has been destroyed.\r\n\t *\r\n\t * @method isDestroyed\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isDestroyed = function() {\r\n\t\treturn this._destroyed;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether the carousel is currently animating.\r\n\t *\r\n\t * @method isAnimating\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isAnimating = function() {\r\n\t\treturn this._isAnimating;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether the carousel is currently animating.\r\n\t *\r\n\t * @method isAnimating\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isDragged = function() {\r\n\t\treturn this._isDragged;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current configuration.\r\n\t *\r\n\t * @method getConfig\r\n\t * @return {Config}\r\n\t */\r\n\tFlowCarousel.prototype.getConfig = function() {\r\n\t\treturn this._config;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current animator instance.\r\n\t *\r\n\t * @method getAnimator\r\n\t * @return {Config}\r\n\t */\r\n\tFlowCarousel.prototype.getAnimator = function() {\r\n\t\treturn this._animator;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the main carousel wrap dom element.\r\n\t *\r\n\t * @method getMainWrap\r\n\t * @return {DOMElement}\r\n\t */\r\n\tFlowCarousel.prototype.getMainWrap = function() {\r\n\t\treturn this._mainWrap;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the items wrap containing the scroller wrap.\r\n\t *\r\n\t * @method getItemsWrap\r\n\t * @return {DOMElement}\r\n\t */\r\n\tFlowCarousel.prototype.getItemsWrap = function() {\r\n\t\treturn this._itemsWrap;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the scroller wrap containing the item wraps.\r\n\t *\r\n\t * @method getScrollerWrap\r\n\t * @return {DOMElement}\r\n\t */\r\n\tFlowCarousel.prototype.getScrollerWrap = function() {\r\n\t\treturn this._scrollerWrap;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the orientation of the carousel.\r\n\t *\r\n\t * @method getOrientation\r\n\t * @return {Config/Orientation:property}\r\n\t */\r\n\tFlowCarousel.prototype.getOrientation = function() {\r\n\t\treturn this._config.orientation;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the size of a single item given current wrap size.\r\n\t *\r\n\t * @method getItemSize\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemSize = function() {\r\n\t\tvar wrapSize = this._getMainWrapSize(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize);\r\n\r\n\t\treturn this._calculateItemSize(wrapSize, itemsPerPage);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the size of a single page of items.\r\n\t *\r\n\t * @method getPageSize\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getPageSize = function() {\r\n\t\tvar wrapSize = this._getMainWrapSize(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize),\r\n\t\t\titemSize = this._calculateItemSize(wrapSize, itemsPerPage);\r\n\r\n\t\treturn itemsPerPage * itemSize;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the size of the entire scroller that would fit all the elements.\r\n\t *\r\n\t * @method getTotalSize\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getTotalSize = function() {\r\n\t\tvar wrapSize = this._getMainWrapSize(),\r\n\t\t\titemCount = this._dataSource.getItemCount(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize),\r\n\t\t\titemSize = this._calculateItemSize(wrapSize, itemsPerPage);\r\n\r\n\t\treturn itemCount * itemSize;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of items in the dataset.\r\n\t *\r\n\t * @method getItemCount\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemCount = function() {\r\n\t\treturn this._dataSource.getItemCount();\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of items on the last page.\r\n\t *\r\n\t * @method getItemCountOnLastPage\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemCountOnLastPage = function() {\r\n\t\tvar itemCount = this.getItemCount(),\r\n\t\t\titemsPerPage = this.getItemsPerPage(),\r\n\t\t\tpageCount = this.getPageCount();\r\n\r\n\t\treturn itemCount - (pageCount - 1) * itemsPerPage;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of pages the dataset contains given current wrap size.\r\n\t *\r\n\t * @method getPageCount\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getPageCount = function() {\r\n\t\treturn Math.ceil(this._dataSource.getItemCount() / this.getItemsPerPage());\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the number of items displayed on a single page.\r\n\t *\r\n\t * Calculating the number of items per page causes a layout which is bad for performance so cached value is used\r\n\t * when possible.\r\n\t *\r\n\t * @method getItemsPerPage\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemsPerPage = function() {\r\n\t\tvar wrapSize = this._getMainWrapSize(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize);\r\n\r\n\t\tthis._cache.itemsPerPage = itemsPerPage;\r\n\r\n\t\treturn itemsPerPage;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the target item position index.\r\n\t *\r\n\t * This can be different from the return value of getCurrentItemIndex() if the carousel is animating.\r\n\t *\r\n\t * @method getTargetItemIndex\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getTargetItemIndex = function() {\r\n\t\treturn this._targetItemIndex;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the current item position index.\r\n\t *\r\n\t * This can be different from the return value of getTargetItemIndex() if the carousel is animating.\r\n\t *\r\n\t * @method getCurrentItemIndex\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentItemIndex = function() {\r\n\t\treturn this._currentItemIndex;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the currently-hovered item index or null if none is hovered.\r\n\t *\r\n\t * @method getHoverItemIndex\r\n\t * @return {number|null}\r\n\t */\r\n\tFlowCarousel.prototype.getHoverItemIndex = function() {\r\n\t\treturn this._hoverItemIndex;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns currently visible page number.\r\n\t *\r\n\t * Always returns an integer flooring to the closest round page number.\r\n\t *\r\n\t * The page number starts at zero for first page.\r\n\t *\r\n\t * @method getCurrentPageIndex\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentPageIndex = function() {\r\n\t\treturn this.getItemPageIndex(this._currentItemIndex);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns given item index page index.\r\n\t *\r\n\t * Always returns an integer flooring to the closest round page number.\r\n\t *\r\n\t * The page number starts at zero for first page.\r\n\t *\r\n\t * @method getItemPageIndex\r\n\t * @param {number} itemIndex Item index to calculate for\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemPageIndex = function(itemIndex) {\r\n\t\tvar itemsPerPage = this.getItemsPerPage();\r\n\r\n\t\treturn Math.floor(itemIndex / itemsPerPage);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns current item absolute position.\r\n\t *\r\n\t * @method getCurrentPosition\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentItemPosition = function() {\r\n\t\treturn this._animator.getCurrentPosition();\r\n\t};\r\n\r\n\t/**\r\n\t * Returns item position at given index.\r\n\t *\r\n\t * @method getItemPositionByIndex\r\n\t * @param {number} itemIndex Item index\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getItemPositionByIndex = function(itemIndex) {\r\n\t\tvar itemSize = this.getItemSize(),\r\n\t\t\titemsPerPage = this.getItemsPerPage(),\r\n\t\t\titemMargin = this._config.margin,\r\n\t\t\tgapPerItem = (itemMargin * (itemsPerPage - 1) / itemsPerPage);\r\n\r\n\t\treturn -Math.floor(itemIndex * itemSize + itemIndex * (itemMargin - gapPerItem));\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the closest full item index at given position taking into account the direction of movement.\r\n\t *\r\n\t * @method getClosestItemIndexAtPosition\r\n\t * @param {number} position Scroller position\r\n\t * @param {number} [direction=1] Move direction (-1/1)\r\n\t * @return {number} Closest item index\r\n\t */\r\n\tFlowCarousel.prototype.getClosestItemIndexAtPosition = function(position, direction) {\r\n\t\tdirection = direction || 1;\r\n\r\n\t\tvar itemSize = this.getItemSize(),\r\n\t\t\titemCount = this.getItemCount(),\r\n\t\t\titemsPerPage = this.getItemsPerPage(),\r\n\t\t\titemMargin = this._config.margin,\r\n\t\t\tgapPerItem = (itemMargin * (itemsPerPage - 1) / itemsPerPage),\r\n\t\t\titemIndex = -position / (itemSize + (itemMargin - gapPerItem)),\r\n\t\t\tresult;\r\n\r\n\t\tif (direction < 0) {\r\n\t\t\tresult = Math.ceil(itemIndex);\r\n\t\t} else {\r\n\t\t\tresult = Math.floor(itemIndex);\r\n\t\t}\r\n\r\n\t\t// limit the range\r\n\t\treturn Math.min(Math.max(result, 0), itemCount - itemsPerPage);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the closest full page index at given position taking into account the direction of movement.\r\n\t *\r\n\t * @method getClosestPageIndexAtPosition\r\n\t * @param {number} position Scroller position\r\n\t * @param {number} [direction=1] Move direction (-1/1)\r\n\t * @return {number} Closest page index\r\n\t */\r\n\tFlowCarousel.prototype.getClosestPageIndexAtPosition = function(position, direction) {\r\n\t\tdirection = direction || 1;\r\n\r\n\t\tvar closestItemIndex = this.getClosestItemIndexAtPosition(position, direction),\r\n\t\t\titemsPerPage = this.getItemsPerPage(),\r\n\t\t\tpageCount = this.getPageCount(),\r\n\t\t\tpageIndex = closestItemIndex / itemsPerPage,\r\n\t\t\tresult;\r\n\r\n\t\tif (direction < 0) {\r\n\t\t\tresult = Math.ceil(pageIndex);\r\n\t\t} else {\r\n\t\t\tresult = Math.floor(pageIndex);\r\n\t\t}\r\n\r\n\t\t// limit the range\r\n\t\treturn Math.min(Math.max(result, 0), pageCount - 1);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the range of items that should be rendered for current item index and config.\r\n\t *\r\n\t * @method getRenderRange\r\n\t * @param {number} [itemIndex=this._currentItemIndex] Optional item index to use, defaults to current\r\n\t * @return {object} Render range with start and end keys\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype.getRenderRange = function(itemIndex) {\r\n\t\titemIndex = itemIndex || this._currentItemIndex;\r\n\r\n\t\tvar itemsPerPage = this.getItemsPerPage(),\r\n\t\t\titemCount = this._dataSource.getItemCount();\r\n\r\n\t\treturn this._config.getRenderRange(itemIndex, itemsPerPage, itemCount);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the range of items that have already been rendered for current item index and config.\r\n\t *\r\n\t * @method getRenderedRange\r\n\t * @return {object|null} Render range with start and end keys or null if no elements have been renderer\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype.getRenderedRange = function() {\r\n\t\tvar range = {\r\n\t\t\t\tstart: null,\r\n\t\t\t\tend: null\r\n\t\t\t},\r\n\t\t\titemIndex,\r\n\t\t\ti;\r\n\r\n\t\tfor (i = 0; i < this._renderedItemIndexes.length; i++) {\r\n\t\t\titemIndex = this._renderedItemIndexes[i];\r\n\r\n\t\t\titemIndex = parseInt(itemIndex, 10);\r\n\r\n\t\t\tif (range.start === null || itemIndex < range.start) {\r\n\t\t\t\trange.start = itemIndex;\r\n\t\t\t}\r\n\r\n\t\t\tif (range.end === null || itemIndex > range.end) {\r\n\t\t\t\trange.end = itemIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (range.start === null || range.end === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn range;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the current item position index.\r\n\t *\r\n\t * This can be different from the return value of getTargetItemIndex() if the carousel is animating.\r\n\t *\r\n\t * @method isAnimating\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isAnimating = function() {\r\n\t\treturn this._isAnimating;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the data source to use.\r\n\t *\r\n\t * Expects either an instance of AbstractDataSource (you can roll your own) or a simple array that will be\r\n\t * converted to an ArrayDataSource.\r\n\t *\r\n\t * This can optionally be set in the init method as second argument.\r\n\t *\r\n\t * This method supports call chaining by returning itself.\r\n\t *\r\n\t * @method setDataSource\r\n\t * @param {AbstractDataSource|array} Either an instance of AbstractDataSource or a simple array\r\n\t * @chainable\r\n\t * @return {FlowCarousel}\r\n\t */\r\n\tFlowCarousel.prototype.setDataSource = function(data) {\r\n\t\tif (data instanceof AbstractDataSource) {\r\n\t\t\tthis._dataSource = data;\r\n\t\t} else if (Util.isArray(data)) {\r\n\t\t\tthis._dataSource = new ArrayDataSource(data);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Invalid data of type \"' + typeof data + '\" provided, expected an instance of AbstractDataSource or ' +\r\n\t\t\t\t'a simple array'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Sets the renderer to use.\r\n\t *\r\n\t * Expects an instance of AbstractRenderer.\r\n\t *\r\n\t * This method supports call chaining by returning itself.\r\n\t *\r\n\t * @method setRenderer\r\n\t * @param {AbstractDataSource|array} Either an instance of AbstractDataSource or a simple array\r\n\t * @chainable\r\n\t * @return {FlowCarousel}\r\n\t */\r\n\tFlowCarousel.prototype.setRenderer = function(renderer) {\r\n\t\tif (renderer instanceof AbstractRenderer) {\r\n\t\t\tthis._renderer = renderer;\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid renderer provided, expected an instance of AbstractRenderer');\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * Adds a new navigator to use.\r\n\t *\r\n\t * @method addNavigator\r\n\t * @param {string} type Type of the navigator, should be unique\r\n\t * @param {AbstractNavigator} instance Navigator instance\r\n\t */\r\n\tFlowCarousel.prototype.addNavigator = function(type, instance) {\r\n\t\tif (typeof this._navigators[type] !== 'undefined') {\r\n\t\t\tthrow new Error('Navigator of type \"' + type + '\" already added');\r\n\t\t}\r\n\r\n\t\tif (!(instance instanceof AbstractNavigator)) {\r\n\t\t\tthrow new Error('The navigator is expected to be an instance of AbstractNavigator');\r\n\t\t}\r\n\r\n\t\tthis._navigators[type] = instance;\r\n\r\n\t\t// initiate the navigator\r\n\t\tthis._navigators[type].init(this);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns navigator instance by type.\r\n\t *\r\n\t * @method getNavigatorByType\r\n\t * @param {string} type Type of the navigator, should be unique\r\n\t * @return {AbstractNavigator|null} Navigator instance or null if not found\r\n\t */\r\n\tFlowCarousel.prototype.getNavigatorByType = function(type) {\r\n\t\tif (typeof this._navigators[type] === 'undefined') {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this._navigators[type];\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the data used for rendering the component.\r\n\t *\r\n\t * Returns null if the component has not yet been initialized.\r\n\t *\r\n\t * @method getDataSource\r\n\t * @return {AbstractDataSource|null} Used data source or null if not available yet\r\n\t */\r\n\tFlowCarousel.prototype.getDataSource = function() {\r\n\t\treturn this._dataSource;\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to a carousel item by index.\r\n\t *\r\n\t * Throws error if out of bounds index is requested.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_ITEM [itemIndex, instant] before animation\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_ITEM [itemIndex, instant] after animation\r\n\t *\r\n\t * @method navigateToItem\r\n\t * @param {number} itemIndex Item index to navigate to\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @param {boolean} [force=false] Force the animation even if we think we're already at given item index\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToItem = function(itemIndex, instant, force) {\r\n\t\tinstant = typeof instant === 'boolean' ? instant : false;\r\n\t\tforce = typeof force === 'boolean' ? force : false;\r\n\r\n\t\tvar deferred = new Deferred(),\r\n\t\t\titemCount = this._dataSource.getItemCount(),\r\n\t\t\tisSameItemIndex = itemIndex === this._currentItemIndex,\r\n\t\t\titemsPerPage = this.getItemsPerPage(),\r\n\t\t\tcurrentItemIndex = this.getCurrentItemIndex(),\r\n\t\t\tpageLastItemIndex = Math.min(currentItemIndex + 1, itemCount - itemsPerPage);\r\n\r\n\t\t// if there are no items then resolve immediately and give up\r\n\t\tif (itemCount === 0) {\r\n\t\t\tdeferred.resolve();\r\n\r\n\t\t\treturn deferred.promise();\r\n\t\t}\r\n\r\n\t\t// validate index range\r\n\t\tif (itemIndex < 0) {\r\n\t\t\tthrow new Error('Invalid negative  index \"' + itemIndex + '\" requested');\r\n\t\t} else if (itemIndex > itemCount - 1) {\r\n\t\t\tthrow new Error('Too large index \"' + itemIndex + '\" requested, there are only ' + itemCount + ' items');\r\n\t\t}\r\n\r\n\t\t// TODO investigate allowing navigation while the previous animation is ongoing\r\n\t\t/*if (this._activeAnimationDeferred !== null) {\r\n\t\t\tthis._activeAnimationDeferred.resolve();\r\n\r\n\t\t\treturn this.navigateToItem(itemIndex,instant, force);\r\n\t\t}*/\r\n\r\n\t\t// ignore navigation request when already navigating\r\n\t\tif (this._isAnimating) {\r\n\t\t\tif (this._activeAnimationDeferred === null) {\r\n\t\t\t\t/* istanbul ignore if */\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t'Carousel is animating but no active animation deferred is present, this should not happen'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn this._activeAnimationDeferred;\r\n\t\t}\r\n\r\n\t\t// animate to the new item position index if it's different from current item index\r\n\t\tif (!isSameItemIndex || force === true) {\r\n\t\t\tthis._isAnimating = true;\r\n\t\t\tthis._targetItemIndex = itemIndex;\r\n\r\n\t\t\t// start animating to given item, this is an asynchronous process\r\n\t\t\tthis._animator.animateToItem(itemIndex, instant).done(function() {\r\n\t\t\t\tdeferred.resolve();\r\n\t\t\t});\r\n\r\n\t\t\t// emitting this event before starting the animation causes lag for some reason\r\n\t\t\tthis.emit(FlowCarousel.Event.NAVIGATING_TO_ITEM, itemIndex, instant);\r\n\t\t} else {\r\n\t\t\t// already at target page index, visualize limit\r\n\t\t\tif (itemIndex === 0 || (this.isLastPage() && itemIndex === pageLastItemIndex)) {\r\n\t\t\t\tthis._showLimit(itemIndex).done(function() {\r\n\t\t\t\t\tdeferred.resolve();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._activeAnimationDeferred = deferred;\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.resolve();\r\n\t\t\t}\r\n\r\n\t\t\treturn deferred.promise();\r\n\t\t}\r\n\r\n\t\t// render placeholders that are later replaced with real loaded items\r\n\t\tif (this._config.usePlaceholders && this._dataSource.isAsynchronous()) {\r\n\t\t\tthis._renderTargetIndexPlaceholders();\r\n\t\t}\r\n\r\n\t\t// once the animation is complete, update the current item index\r\n\t\tdeferred.done(function() {\r\n\t\t\tthis._currentItemIndex = this._targetItemIndex;\r\n\t\t\tthis._lastCenterItemIndex = this.getCurrentCenterItemIndex();\r\n\t\t\tthis._isAnimating = false;\r\n\t\t\tthis._activeAnimationDeferred = null;\r\n\r\n\t\t\t// remove items that have moved out of range\r\n\t\t\tthis._destroyInvalidItems();\r\n\r\n\t\t\t// check whether we need to render or remove some items\r\n\t\t\tthis._validateItemsToRender().done(function() {\r\n\t\t\t\t// update scroller size to largest visible child\r\n\t\t\t\tthis.validateSize();\r\n\t\t\t}.bind(this));\r\n\r\n\t\t\tthis.emit(FlowCarousel.Event.NAVIGATED_TO_ITEM, itemIndex, instant);\r\n\t\t}.bind(this));\r\n\r\n\t\t// store the promise so it can be returned when requesting a new animation while the last still playing\r\n\t\tthis._activeAnimationDeferred = deferred;\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to given page number.\r\n\t *\r\n\t * Notice that page numbers start from zero.\r\n\t *\r\n\t * Throws error if out of bounds index is requested.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_PAGE at the start of the procedure\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_PAGE after the animation to requested page\r\n\t *\r\n\t * @method navigateToPage\r\n\t * @param {number} pageIndex Page index to navigate to\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @param {boolean} [force=false] Force the animation even if we think we're already at given item index\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToPage = function(pageIndex, instant, force) {\r\n\t\tinstant = typeof instant === 'boolean' ? instant : false;\r\n\r\n\t\tvar currentPageIndex = this.getCurrentPageIndex(),\r\n\t\t\titemIndex = pageIndex * this.getItemsPerPage(),\r\n\t\t\t// TODO this needs change in getCurrentPageIndex as well\r\n\t\t\t//itemIndex = Math.min(pageIndex * this.getItemsPerPage(), this.getMaximumValidItemIndex()),\r\n\t\t\tpageCount = this.getPageCount(),\r\n\t\t\tdeferred = new Deferred();\r\n\r\n\t\t// already at target page index, visualize limit\r\n\t\tif (pageIndex === currentPageIndex && force !== true) {\r\n\t\t\tif (\r\n\t\t\t\t(pageIndex === 0 || pageIndex === pageCount - 1)\r\n\t\t\t\t&& this.getPageCount() > 1\r\n\t\t\t) {\r\n\t\t\t\tthis._showLimit(itemIndex).done(function() {\r\n\t\t\t\t\tdeferred.resolve();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._activeAnimationDeferred = deferred;\r\n\t\t\t} else {\r\n\t\t\t\tdeferred.resolve();\r\n\t\t\t}\r\n\r\n\t\t\treturn deferred.promise();\r\n\t\t}\r\n\r\n\t\tthis.emit(FlowCarousel.Event.NAVIGATING_TO_PAGE, pageIndex, instant);\r\n\r\n\t\tthis.navigateToItem(itemIndex, instant, force).done(function() {\r\n\t\t\tdeferred.resolve();\r\n\t\t});\r\n\r\n\t\tdeferred.done(function() {\r\n\t\t\tthis.emit(FlowCarousel.Event.NAVIGATED_TO_PAGE, pageIndex, instant);\r\n\t\t}.bind(this));\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to next carousel item.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_ITEM [itemIndex, instant] before animation\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_ITEM [itemIndex, instant] after animation\r\n\t *\r\n\t * @method navigateToNextItem\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToNextItem = function(instant) {\r\n\t\tvar currentItemIndex = this.getCurrentItemIndex(),\r\n\t\t\tmaximumValidItemIndex = this.getMaximumValidItemIndex(),\r\n\t\t\ttargetItemIndex = Math.min(currentItemIndex + 1, maximumValidItemIndex);\r\n\r\n\t\treturn this.navigateToItem(targetItemIndex, instant);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the maximum item index to scroll to so that the last page would be displayed full.\r\n\t *\r\n\t * @method getMaximumValidItemIndex\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getMaximumValidItemIndex = function() {\r\n\t\tvar itemsPerPage = this.getItemsPerPage(),\r\n\t\t\titemCount = this.getItemCount();\r\n\r\n\t\treturn Math.max(itemCount - itemsPerPage, 0);\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to previous carousel item.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_ITEM [itemIndex, instant] before animation\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_ITEM [itemIndex, instant] after animation\r\n\t *\r\n\t * @method navigateToPreviousItem\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToPreviousItem = function(instant) {\r\n\t\tvar currentItemIndex = this.getCurrentItemIndex(),\r\n\t\t\ttargetItemIndex = Math.max(currentItemIndex - 1, 0);\r\n\r\n\t\treturn this.navigateToItem(targetItemIndex, instant);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether given (or current if no argument is given) item is the first one.\r\n\t *\r\n\t * @method isFirstItem\r\n\t * @param {number} [itemIndex=getCurrentItemIndex()] Optional item index, current by default\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isFirstItem = function(itemIndex) {\r\n\t\titemIndex = typeof itemIndex === 'number' ? itemIndex : this.getCurrentPageIndex();\r\n\r\n\t\treturn itemIndex === 0;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether given (or current if no argument is given) item is the last one.\r\n\t *\r\n\t * @method isLastItem\r\n\t * @param {number} [itemIndex=getCurrentItemIndex()] Optional item index, current by default\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isLastItem = function(itemIndex) {\r\n\t\titemIndex = typeof itemIndex === 'number' ? itemIndex : this.getCurrentItemIndex();\r\n\r\n\t\treturn this.getItemCount() === 0 || itemIndex >= this.getMaximumValidItemIndex();\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether given (or current if no argument is given) page is the first one.\r\n\t *\r\n\t * @method isFirstPage\r\n\t * @param {number} [pageIndex=getCurrentPageIndex()] Optional page index, current by default\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isFirstPage = function(pageIndex) {\r\n\t\tpageIndex = typeof pageIndex === 'number' ? pageIndex : this.getCurrentPageIndex();\r\n\r\n\t\treturn pageIndex === 0;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether given (or current if no argument is given) page is the last one.\r\n\t *\r\n\t * @method isLastPage\r\n\t * @param {number} [pageIndex=getCurrentPageIndex()] Optional page index, current by default\r\n\t * @return {boolean}\r\n\t */\r\n\tFlowCarousel.prototype.isLastPage = function(pageIndex) {\r\n\t\tpageIndex = typeof pageIndex === 'number' ? pageIndex : this.getCurrentPageIndex();\r\n\r\n\t\treturn this.getPageCount() === 0 || pageIndex === this.getPageCount() - 1;\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to next page if available.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_PAGE at the start of the procedure\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_PAGE after the animation to requested page\r\n\t *\r\n\t * @method navigateToNextPage\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToNextPage = function(instant) {\r\n\t\tvar currentPageIndex = this.getCurrentPageIndex(),\r\n\t\t\tpageCount = this.getPageCount(),\r\n\t\t\ttargetPageIndex = Math.min(currentPageIndex + 1, pageCount - 1);\r\n\r\n\t\treturn this.navigateToPage(targetPageIndex, instant);\r\n\t};\r\n\r\n\t/**\r\n\t * Navigates to previous page if available.\r\n\t *\r\n\t * Returns deferred promise that will be resolved once the animation completes.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.NAVIGATING_TO_PAGE at the start of the procedure\r\n\t * - FlowCarousel.Event.NAVIGATED_TO_PAGE after the animation to requested page\r\n\t *\r\n\t * @method navigateToPreviousPage\r\n\t * @param {boolean} [instant=false] Should the navigation be instantaneous and not use animation\r\n\t * @return {Deferred.Promise} Deferred promise that will be resolved once the animation completes\r\n\t */\r\n\tFlowCarousel.prototype.navigateToPreviousPage = function(instant) {\r\n\t\tvar currentPageIndex = this.getCurrentPageIndex(),\r\n\t\t\ttargetPageIndex = Math.max(currentPageIndex - 1, 0);\r\n\r\n\t\treturn this.navigateToPage(targetPageIndex, instant);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the range of currently visible carousel item wrappers.\r\n\t *\r\n\t * @method getCurrentPageVisibleRange\r\n\t * @return {object}\r\n\t * @return {number} return.start Visible range start index\r\n\t * @return {number} return.end Visible range end index\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentPageVisibleRange = function() {\r\n\t\tvar itemsPerPage = this.getItemsPerPage(),\r\n\t\t\titemCount = this.getItemCount();\r\n\r\n\t\treturn {\r\n\t\t\tstart: this._currentItemIndex,\r\n\t\t\tend: Math.max(Math.min(this._currentItemIndex + itemsPerPage - 1, itemCount - 1), 0)\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the list of currently visible carousel item wrappers.\r\n\t *\r\n\t * @method getCurrentPageVisibleItemElements\r\n\t * @return {DOMElement[]}\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentPageVisibleItemElements = function() {\r\n\t\tvar itemCount = this.getItemCount(),\r\n\t\t\tvisibleRange = this.getCurrentPageVisibleRange(),\r\n\t\t\telements = [],\r\n\t\t\telement,\r\n\t\t\ti;\r\n\r\n\t\t// return empty array if there are no items\r\n\t\tif (itemCount === 0) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tfor (i = visibleRange.start; i <= visibleRange.end; i++) {\r\n\t\t\telement = this.getItemElementByIndex(i);\r\n\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (element === null) {\r\n\t\t\t\tthrow new Error('Requested item element at index #' + i + ' not found, this should not happen');\r\n\t\t\t}\r\n\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\r\n\t\treturn elements;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the item dom element by item index.\r\n\t *\r\n\t * Throws error if invalid index is requested.\r\n\t *\r\n\t * @method getItemElementByIndex\r\n\t * @param {number} itemIndex Item index to fetch element of\r\n\t * @return {DOMElement|null} Item dom element or null if not found\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype.getItemElementByIndex = function(itemIndex) {\r\n\t\tvar itemCount = this.getItemCount();\r\n\r\n\t\t// nothing to search for\r\n\t\tif (itemCount === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// validate index range\r\n\t\tif (itemIndex < 0) {\r\n\t\t\tthrow new Error('Invalid negative  index \"' + itemIndex + '\" requested');\r\n\t\t} else if (itemIndex > itemCount - 1) {\r\n\t\t\tthrow new Error('Too large index \"' + itemIndex + '\" requested, there are only ' + itemCount + ' items');\r\n\t\t}\r\n\r\n\t\tif (typeof this._itemIndexToElementMap[itemIndex] === 'undefined') {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this._itemIndexToElementMap[itemIndex];\r\n\t};\r\n\r\n\t/**\r\n\t * Validates the dataset and redraws the carousel.\r\n\t *\r\n\t * You can call this when the data has changes in the background and the carousel should redraw itself.\r\n\t *\r\n\t * Returns promise that is resolved when the new items has been drawn.\r\n\t *\r\n\t * @method redraw\r\n\t * @return {Deferred.Promise}\r\n\t */\r\n\tFlowCarousel.prototype.redraw = function() {\r\n\t\treturn this._reLayout();\r\n\t};\r\n\r\n\t/**\r\n\t * Calculates the item index to scroll to so that the given index would be centered if possible.\r\n\t *\r\n\t * @method calculateCenteredItemStartIndex\r\n\t * @param {number} startItemIndex Item index to center\r\n\t * @param {boolean} [inverse=false] Should the inverse positive index be returned\r\n\t */\r\n\tFlowCarousel.prototype.calculateCenteredItemStartIndex = function(startItemIndex, inverse) {\r\n\t\tinverse = typeof inverse === 'boolean' ? inverse : false;\r\n\r\n\t\tvar maximumValidItemIndex = this.getMaximumValidItemIndex(),\r\n\t\t\titemPerPage = this.getItemsPerPage(),\r\n\t\t\tisEvenNumberOfPages = itemPerPage % 2 === 0,\r\n\t\t\tsign = inverse ? 1 : -1,\r\n\t\t\troundMethod = inverse ? 'floor' : 'ceil',\r\n\t\t\tcenteredItemIndex = Math[roundMethod](startItemIndex + sign * itemPerPage / 2);\r\n\r\n\t\t// prefer before the center rather than after\r\n\t\tif (isEvenNumberOfPages) {\r\n\t\t\tcenteredItemIndex -= 1;\r\n\t\t}\r\n\r\n\t\t// limit the calculated item index to valid range\r\n\t\treturn Math.max(Math.min(centeredItemIndex, maximumValidItemIndex), 0);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns currently centered item index.\r\n\t *\r\n\t * @method getCurrentCenterItemIndex\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype.getCurrentCenterItemIndex = function() {\r\n\t\treturn this.calculateCenteredItemStartIndex(this._currentItemIndex, true);\r\n\t};\r\n\r\n\t/**\r\n\t * Initializes the top-level wrap element.\r\n\t *\r\n\t * If the selector matches multiple elements, only the first one is considered.\r\n\t *\r\n\t * If the selector does not match any elements, an error is thrown.\r\n\t *\r\n\t * @method _setupElement\r\n\t * @param {string|jQuery|DOMElement} source Wraps element or selector\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._setupElement = function(source) {\r\n\t\tvar matches = $(source),\r\n\t\t\telement,\r\n\t\t\texistingCarousel;\r\n\r\n\t\t// make sure that the selector matches only a single element and throw error otherwise\r\n\t\tif (matches.length === 0) {\r\n\t\t\tthrow new Error('Selector \"' + element + '\" did not match any elements');\r\n\t\t} else if (matches.length > 1) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Selector \"' + element + '\" matches more then one element, try using \"' + element + ':first\"'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\telement = matches[0];\r\n\t\texistingCarousel = $(element).data(this._config.dataTarget);\r\n\r\n\t\t// make sure the same element is not initiated several times\r\n\t\tif (existingCarousel instanceof FlowCarousel) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Element matching selector \"' + element + '\" is already a carousel component, ' +\r\n\t\t\t\t'destroy the existing one first'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// store reference to the main wrap dom element\r\n\t\tthis._mainWrap = element;\r\n\r\n\t\t// register the carousel instance on the main wrap dom element data\r\n\t\t$(this._mainWrap).data(this._config.dataTarget, this);\r\n\t};\r\n\r\n\t/**\r\n\t * Initializes a single wrap element.\r\n\t *\r\n\t * @method _setupCarousel\r\n\t * @param {DOMelement} wrap The carousel wrap to setup\r\n\t * @param {Config/Orientation:property} orientation Orientation to use\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._setupCarousel = function(wrap, orientation) {\r\n\t\tvar $element = $(wrap),\r\n\t\t\tclassName = {\r\n\t\t\t\twrap: this._config.getClassName('wrap'),\r\n\t\t\t\titems: this._config.getClassName('items'),\r\n\t\t\t\titem: this._config.getClassName('item'),\r\n\t\t\t\tscroller: this._config.getClassName('scroller'),\r\n\t\t\t\tmatchWrap: this._config.getClassName('matchWrap'),\r\n\t\t\t\tmatchLargestItem: this._config.getClassName('matchLargestItem'),\r\n\t\t\t\tinitiating: this._config.getClassName('initiating'),\r\n\t\t\t\thorizontal: this._config.getClassName('horizontal'),\r\n\t\t\t\tvertical: this._config.getClassName('vertical')\r\n\t\t\t},\r\n\t\t\tsizeMode = this._config.sizeMode,\r\n\t\t\tstartItemIndex = 0,\r\n\t\t\t$itemsWrap,\r\n\t\t\t$scrollerWrap;\r\n\r\n\t\t// remove any existing content (HtmlDataSource should have done that already anyway\r\n\t\t$element.empty();\r\n\r\n\t\t// create the items and the scroller wraps\r\n\t\t$itemsWrap = $('<div></div>', {\r\n\t\t\t'class': className.items\r\n\t\t});\r\n\r\n\t\t$scrollerWrap = $('<div></div>', {\r\n\t\t\t'class': className.scroller\r\n\t\t});\r\n\r\n\t\t// add size mode class to the main wrap element\r\n\t\tif (sizeMode === Config.SizeMode.MATCH_WRAP) {\r\n\t\t\t$(this._mainWrap).addClass(className.matchWrap);\r\n\t\t} else if (sizeMode === Config.SizeMode.MATCH_LARGEST_ITEM) {\r\n\t\t\t$(this._mainWrap).addClass(className.matchLargestItem);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid size mode \"' + sizeMode + '\" defined');\r\n\t\t}\r\n\r\n\t\t// add the items and scroller wraps\r\n\t\t$itemsWrap.append($scrollerWrap);\r\n\t\t$element.append($itemsWrap);\r\n\r\n\t\t// store references to the items and scroller wrap dom elements\r\n\t\tthis._itemsWrap = $itemsWrap[0];\r\n\t\tthis._scrollerWrap = $scrollerWrap[0];\r\n\r\n\t\t// add main carousel class to the wrap element\r\n\t\t$element.addClass(className.wrap);\r\n\t\t$element.addClass(className.initiating);\r\n\r\n\t\t// add class to wrap based on orientation\r\n\t\tif (orientation === Config.Orientation.HORIZONTAL) {\r\n\t\t\t$element.addClass(className.horizontal);\r\n\t\t} else if (orientation === Config.Orientation.VERTICAL) {\r\n\t\t\t$element.addClass(className.vertical);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Unexpected orientation \"' + orientation + '\" provided');\r\n\t\t}\r\n\r\n\t\tif (this._config.startItemIndex !== null) {\r\n\t\t\tstartItemIndex = this._config.startItemIndex;\r\n\t\t} else if (this._config.startPageIndex !== null) {\r\n\t\t\tstartItemIndex = this._config.startPageIndex * this.getItemsPerPage();\r\n\t\t}\r\n\r\n\t\t// notify the animator that carousel element is ready\r\n\t\tthis._animator.onCarouselElementReady();\r\n\r\n\t\t// setup the main layout and move/animate to the start item\r\n\t\tthis._setupLayout(startItemIndex, this._config.animateToStartIndex, this._config.centerStartItemIndex);\r\n\r\n\t\t// remove the loading class\r\n\t\t$element.removeClass(className.initiating);\r\n\r\n\t\t// throw error if both item and page start indexes are set\r\n\t\tif (this._config.startItemIndex !== null && this._config.startPageIndex !== null) {\r\n\t\t\tthrow new Error('Set either the startItemIndex or startPageIndex option but not both');\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Sets up the layout and renders the initial set of items.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.LAYOUT_CHANGED when the layout changes\r\n\t *\r\n\t * @method _setupLayout\r\n\t * @param {number} [startItemIdex] Optional item index to navigate to instantly\r\n\t * @param {boolean} [animateToStartItem=false] Should we animate to the start item\r\n\t * @param {boolean} [centerStartItemIndex=false] Should we try to center on the start item\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._setupLayout = function(startItemIndex, animateToStartItem, centerStartItemIndex) {\r\n\t\tvar orientation = this._config.orientation,\r\n\t\t\twrapSize = this._getMainWrapSize(),\r\n\t\t\titemCount = this._dataSource.getItemCount(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize),\r\n\t\t\titemSize = this._calculateItemSize(wrapSize, itemsPerPage),\r\n\t\t\ttotalSize = Math.ceil(itemCount * itemSize),\r\n\t\t\tinstantAnimation = animateToStartItem !== true,\r\n\t\t\tsizeProp = orientation === Config.Orientation.HORIZONTAL\r\n\t\t\t\t? 'width'\r\n\t\t\t\t: 'height';\r\n\r\n\t\t// the wrap size can become zero when hidden, stop the layout process\r\n\t\t/* istanbul ignore if */\r\n\t\tif (wrapSize === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// define the scroller wrap size to fit all items\r\n\t\t$(this._scrollerWrap).css(sizeProp, totalSize);\r\n\r\n\t\t// if the start item index is set then navigate to it instantly\r\n\t\tif (typeof startItemIndex === 'number' && startItemIndex !== 0) {\r\n\t\t\t// recalculate the start item index so the initial item is shown centered\r\n\t\t\tif (centerStartItemIndex) {\r\n\t\t\t\tstartItemIndex = this.calculateCenteredItemStartIndex(startItemIndex);\r\n\t\t\t}\r\n\r\n\t\t\tthis._targetItemIndex = startItemIndex;\r\n\t\t\tthis._currentItemIndex = startItemIndex;\r\n\t\t\tthis._lastCenterItemIndex = this.getCurrentCenterItemIndex();\r\n\r\n\t\t\tthis.emit(FlowCarousel.Event.NAVIGATING_TO_ITEM, startItemIndex, instantAnimation);\r\n\r\n\t\t\tthis._animator.animateToItem(startItemIndex, instantAnimation, true).done(function() {\r\n\t\t\t\tthis.emit(FlowCarousel.Event.NAVIGATED_TO_ITEM, startItemIndex, instantAnimation);\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\r\n\t\t// render placeholders that are later replaced with real loaded items\r\n\t\tif (this._config.usePlaceholders && this._dataSource.isAsynchronous()) {\r\n\t\t\tthis._renderTargetIndexPlaceholders();\r\n\t\t}\r\n\r\n\t\tthis.emit(FlowCarousel.Event.LAYOUT_CHANGED);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets up the default navigators to use as defined in the {{#crossLink \"Config\"}}{{/crossLink}}.\r\n\t *\r\n\t * @method _setupDefaultNavigators\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._setupDefaultNavigators = function() {\r\n\t\tvar type;\r\n\r\n\t\tfor (type in this._config.navigators) {\r\n\t\t\tif (typeof this._config.navigators[type].createInstance !== 'function') {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t'Expected the navigator definition to include \"createInstance\" method that returns a deferred ' +\r\n\t\t\t\t\t'promise that is resolved with a new instance of the given navigator'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// skip disabled navigators\r\n\t\t\tif (!this._config.navigators[type].enabled) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// create navigator instance asyncronously and add it\r\n\t\t\tDeferred.when(this._config.navigators[type].createInstance(this)).done(function(navigator) {\r\n\t\t\t\t// the carousel may have gotten destroyed while the navigator was loading\r\n\t\t\t\tif (this.carousel === null || this.carousel.isDestroyed()) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.carousel.addNavigator(this.type, navigator);\r\n\t\t\t}.bind({carousel: this, type: type}));\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Validates whether all the required items have been rendered and initiates rendering them if not.\r\n\t *\r\n\t * @method _validateItemsToRender\r\n\t * @return {Deferred.Promise}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._validateItemsToRender = function() {\r\n\t\tvar renderRange = this.getRenderRange();\r\n\r\n\t\treturn this._renderItemRange(renderRange.start, renderRange.end);\r\n\t};\r\n\r\n\t/**\r\n\t * Removes items that have gone out of the render range.\r\n\t *\r\n\t * @method _destroyInvalidItems\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._destroyInvalidItems = function() {\r\n\t\tvar renderRange = this.getRenderRange(),\r\n\t\t\tfilteredPlaceholderItemIndexes = [],\r\n\t\t\tfilteredRenderedItemIndexes = [],\r\n\t\t\tdestroyedItemIndexes = [],\r\n\t\t\titemIndex,\r\n\t\t\titemElement,\r\n\t\t\ti;\r\n\r\n\t\t// destroy rendered placeholders out of the render range\r\n\t\t// TODO the placeholders and real items destroying should be merged\r\n\t\tfor (i = 0; i < this._renderedPlaceholderIndexes.length; i++) {\r\n\t\t\titemIndex = this._renderedPlaceholderIndexes[i];\r\n\r\n\t\t\tif (itemIndex < renderRange.start || itemIndex > renderRange.end) {\r\n\t\t\t\titemElement = this.getItemElementByIndex(itemIndex);\r\n\r\n\t\t\t\t/* istanbul ignore if */\r\n\t\t\t\tif (itemElement === null) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'Placeholder element at index #' + itemIndex + ' not found, this should not happen'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._destroyItem(itemElement, itemIndex);\r\n\r\n\t\t\t\tdestroyedItemIndexes.push(itemIndex);\r\n\t\t\t} else {\r\n\t\t\t\tfilteredPlaceholderItemIndexes.push(itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._renderedPlaceholderIndexes = filteredPlaceholderItemIndexes;\r\n\r\n\t\t// destroy rendered items out of the render range\r\n\t\tfor (i = 0; i < this._renderedItemIndexes.length; i++) {\r\n\t\t\titemIndex = this._renderedItemIndexes[i];\r\n\r\n\t\t\tif (itemIndex < renderRange.start || itemIndex > renderRange.end) {\r\n\t\t\t\titemElement = this.getItemElementByIndex(itemIndex);\r\n\r\n\t\t\t\t/* istanbul ignore if */\r\n\t\t\t\tif (itemElement === null) {\r\n\t\t\t\t\tthrow new Error('Item element at index #' + itemIndex + ' not found, this should not happen');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._destroyItem(itemElement, itemIndex);\r\n\r\n\t\t\t\tdestroyedItemIndexes.push(itemIndex);\r\n\t\t\t} else {\r\n\t\t\t\tfilteredRenderedItemIndexes.push(itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (destroyedItemIndexes.length > 0) {\r\n\t\t\tthis.emit(FlowCarousel.Event.DESTROYED_ITEMS, destroyedItemIndexes);\r\n\t\t}\r\n\r\n\t\tthis._renderedItemIndexes = filteredRenderedItemIndexes;\r\n\t};\r\n\r\n\t/**\r\n\t * Destroys an element and removes it from the index to element mapping.\r\n\t *\r\n\t * @method _destroyItem\r\n\t * @param {DOMElement} element Element to destroy\r\n\t * @param {number} index Element index\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._destroyItem = function(element, index) {\r\n\t\tthis._renderer.destroyItem(element);\r\n\r\n\t\tthis._removeItemIndexToElement(index);\r\n\t};\r\n\r\n\t/**\r\n\t * Renders the item placeholders for current target index.\r\n\t *\r\n\t * @method _renderTargetIndexPlaceholders\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._renderTargetIndexPlaceholders = function() {\r\n\t\tvar targetItemIndex = this._targetItemIndex,\r\n\t\t\trenderRange = this.getRenderRange(targetItemIndex);\r\n\r\n\t\t// render placeholders that are later replaced with real loaded items\r\n\t\t// TODO this is not needed for syncronous data source\r\n\t\tthis._renderItemPlaceholders(renderRange.start, renderRange.end);\r\n\t};\r\n\r\n\t/**\r\n\t * Renders the item placeholders that will later be replaced with the actual items.\r\n\t *\r\n\t * Gives the user some \"loading\" feedback.\r\n\t *\r\n\t * @method _renderItemPlaceholders\r\n\t * @param {number} startIndex The starting index\r\n\t * @param {number} endIndex The end item index\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._renderItemPlaceholders = function(startIndex, endIndex) {\r\n\t\tvar elements = [],\r\n\t\t\telement,\r\n\t\t\titemIndex;\r\n\r\n\t\tfor (itemIndex = startIndex; itemIndex <= endIndex; itemIndex++) {\r\n\t\t\t// don't render a placeholder onto already existing rendered item\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (this._renderedItemIndexes.indexOf(itemIndex) !== -1) {\r\n\t\t\t\telements.push(null);\r\n\t\t\t} else {\r\n\t\t\t\t// request the placeholder element from the renderer\r\n\t\t\t\telement = this._renderer.renderPlaceholder(this._config, itemIndex);\r\n\r\n\t\t\t\telements.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._insertRenderedElements(elements, startIndex, true);\r\n\t};\r\n\r\n\t/**\r\n\t * Renders a range of carousel items.\r\n\t *\r\n\t * Emits:\r\n\t * - FlowCarousel.Event.LOADING_ITEMS [startIndex, endIndex] before starting to load a range of items\r\n\t * - FlowCarousel.Event.ABORTED_ITEMS [startIndex, endIndex] if loading or a range of items was aborted\r\n\t * - FlowCarousel.Event.LOADED_ITEMS [startIndex, endIndex, items] after loading and rendering a range of items\r\n\t * - FlowCarousel.Event.STARTUP_ITEMS_RENDERED if the rendered range of items was the first\r\n\t *\r\n\t * @method _renderItemRange\r\n\t * @param {number} startIndex Range start index\r\n\t * @param {number} endIndex Range end index\r\n\t * @return {Deferred.Promise}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._renderItemRange = function(startIndex, endIndex) {\r\n\t\tvar self = this,\r\n\t\t\tdeferred = new Deferred(),\r\n\t\t\tloadingClassName = this._config.getClassName('loading'),\r\n\t\t\trenderedRange = this.getRenderedRange(),\r\n\t\t\tdir = renderedRange === null || startIndex >= renderedRange.start ? 1 : -1,\r\n\t\t\tloadRange;\r\n\r\n\t\t// don't render anything if already rendered same range\r\n\t\tif (renderedRange !== null && renderedRange.start === startIndex && renderedRange.end === endIndex) {\r\n\t\t\tdeferred.resolve();\r\n\r\n\t\t\treturn deferred.promise();\r\n\t\t}\r\n\r\n\t\tif (renderedRange === null) {\r\n\t\t\tloadRange = {\r\n\t\t\t\tstart: startIndex,\r\n\t\t\t\tend: endIndex\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tif (dir === 1) {\r\n\t\t\t\tloadRange = {\r\n\t\t\t\t\tstart: Math.max(startIndex, renderedRange.end + 1),\r\n\t\t\t\t\tend: endIndex\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tloadRange = {\r\n\t\t\t\t\tstart: startIndex,\r\n\t\t\t\t\tend: Math.min(endIndex, renderedRange.start - 1)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// for asyncronous data source add the loading class to the main wrap for the duration of the async request\r\n\t\tif (this._dataSource.isAsynchronous()) {\r\n\t\t\t$(this._mainWrap).addClass(loadingClassName);\r\n\t\t}\r\n\r\n\t\t// try to abort existing item loading if possible\r\n\t\tif (this._getItemsPromise !== null) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (typeof this._getItemsPromise.abort === 'function') {\r\n\t\t\t\tthis._getItemsPromise.abort();\r\n\t\t\t}\r\n\r\n\t\t\tthis._getItemsPromise._ignore = true;\r\n\r\n\t\t\tthis._getItemsPromise = null;\r\n\t\t}\r\n\r\n\t\tthis.emit(FlowCarousel.Event.LOADING_ITEMS, loadRange.start, loadRange.end);\r\n\r\n\t\t// store the new itemset fetching deferred promise and fetch new items\r\n\t\tthis._getItemsPromise = this._dataSource.getItems(loadRange.start, loadRange.end)\r\n\t\t\t.done(function(items) {\r\n\t\t\t\t// the carousel may get destroyed while the items are loading\r\n\t\t\t\tif (!self._initiated) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// ignore invalid data if it couldn't be aborted\r\n\t\t\t\tif (this._ignore === true) {\r\n\t\t\t\t\tself.emit(FlowCarousel.Event.ABORTED_ITEMS, loadRange.start, loadRange.end, items);\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tself.emit(FlowCarousel.Event.LOADED_ITEMS, loadRange.start, loadRange.end, items);\r\n\r\n\t\t\t\tself._getItemsPromise = null;\r\n\r\n\t\t\t\tif (self._dataSource.isAsynchronous()) {\r\n\t\t\t\t\t$(self._mainWrap).removeClass(loadingClassName);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// rendering items can be asyncronous as well\r\n\t\t\t\tself._renderItems(items, loadRange.start).done(function() {\r\n\t\t\t\t\t// it's possible that the initial first page data loading was cancelled\r\n\t\t\t\t\tif (!this._startupItemsRenderedEmitted) {\r\n\t\t\t\t\t\tthis.emit(FlowCarousel.Event.STARTUP_ITEMS_RENDERED);\r\n\r\n\t\t\t\t\t\tthis._startupItemsRenderedEmitted = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeferred.resolve();\r\n\t\t\t\t}.bind(self));\r\n\t\t\t});\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Renders given carousel items.\r\n\t *\r\n\t * @method _renderItems\r\n\t * @param {array} items Items to render\r\n\t * @param {number} startIndex Range start index\r\n\t * @return {Deferred.Promise}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._renderItems = function(items, startIndex) {\r\n\t\tvar deferred = new Deferred(),\r\n\t\t\trenderRange = this.getRenderRange(),\r\n\t\t\trenderingClassName = this._config.getClassName('rendering'),\r\n\t\t\tendIndex = startIndex + items.length - 1,\r\n\t\t\tpromises = [],\r\n\t\t\toutOfRange,\r\n\t\t\titemIndex,\r\n\t\t\titem,\r\n\t\t\tpromise,\r\n\t\t\texistingElement,\r\n\t\t\texistingElementPos,\r\n\t\t\ti;\r\n\r\n\t\t// it is possible that the carousel HTML element gets removed from DOM while the async request completes\r\n\t\t/* istanbul ignore if */\r\n\t\tif ($(this._mainWrap).parent().length === 0) {\r\n\t\t\tdeferred.resolve();\r\n\r\n\t\t\treturn deferred.promise();\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < items.length; i++) {\r\n\t\t\titem = items[i];\r\n\t\t\titemIndex = startIndex + i;\r\n\t\t\toutOfRange = itemIndex < renderRange.start || itemIndex > renderRange.end;\r\n\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (outOfRange) {\r\n\t\t\t\texistingElement = this._itemIndexToElementMap[itemIndex];\r\n\r\n\t\t\t\tif (typeof existingElement !== 'undefined') {\r\n\t\t\t\t\tthis._renderer.destroyItem(existingElement);\r\n\r\n\t\t\t\t\tthis._removeItemIndexToElement(itemIndex);\r\n\r\n\t\t\t\t\t// remove the item from the placeholder item indexes list if exists\r\n\t\t\t\t\texistingElementPos = this._renderedPlaceholderIndexes.indexOf(itemIndex);\r\n\r\n\t\t\t\t\tif (existingElementPos !== -1) {\r\n\t\t\t\t\t\tthis._renderedPlaceholderIndexes.splice(existingElementPos, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// only render the item if it's not already rendered and it's not out of current render range\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this._renderedItemIndexes.indexOf(itemIndex) === -1 && !outOfRange) {\r\n\t\t\t\tpromise = this._renderer.renderItem(this._config, itemIndex, item);\r\n\t\t\t} else {\r\n\t\t\t\tpromise = null;\r\n\t\t\t}\r\n\r\n\t\t\tpromises.push(promise);\r\n\t\t}\r\n\r\n\t\t// add the rendering class to the main wrap for the duration of the rendering process\r\n\t\t$(this._mainWrap).addClass(renderingClassName);\r\n\r\n\t\t// wait for all the elements to get rendered\r\n\t\t// TODO Add each element as soon as it renders?\r\n\t\tDeferred.when.apply($, promises)\r\n\t\t\t.done(function() {\r\n\t\t\t\t// the carousel may get destroyed while the items are loading\r\n\t\t\t\tif (!this._initiated) {\r\n\t\t\t\t\t//return; // TODO restore\r\n\t\t\t\t\tthrow new Error('Carousel was destroyed before rendering items');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t$(this._mainWrap).removeClass(renderingClassName);\r\n\r\n\t\t\t\tthis._insertRenderedElements(arguments, startIndex);\r\n\r\n\t\t\t\tthis.emit(FlowCarousel.Event.RENDERED_ITEMS, startIndex, endIndex, arguments);\r\n\r\n\t\t\t\tdeferred.resolve();\r\n\t\t\t}.bind(this));\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Inserts rendered dom elements into the carousel dom structure.\r\n\t *\r\n\t * @method _insertRenderedElements\r\n\t * @param {DOMElement[]} elements Elements to insert\r\n\t * @param {number} startIndex First element index in the carousel\r\n\t * @param {boolean} [arePlaceholders=false] Are the elements placeholders\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._insertRenderedElements = function(elements, startIndex, arePlaceholders) {\r\n\t\tvar useFragment = typeof document.createDocumentFragment === 'function',\r\n\t\t\t$elementRangeFragment = useFragment ? $(document.createDocumentFragment()) : null,\r\n\t\t\t$elementWrapElement = useFragment ? $elementRangeFragment : $(this._scrollerWrap),\r\n\t\t\titemIndex,\r\n\t\t\tplaceholderPos,\r\n\t\t\tplaceholderElement,\r\n\t\t\ti;\r\n\r\n\t\t// it is possible that the carousel HTML element gets removed from DOM while the async request completes\r\n\t\t/* istanbul ignore if */\r\n\t\tif ($(this._mainWrap).parent().length === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < elements.length; i++) {\r\n\t\t\t// elements that were already rendered were set to null in _renderItems(), skip these\r\n\t\t\tif (elements[i] === null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\titemIndex = startIndex + i;\r\n\r\n\t\t\t// add the rendered and inserted items to the list of rendered items and the index to element mapping\r\n\t\t\tif (!arePlaceholders) {\r\n\t\t\t\tplaceholderPos = this._renderedPlaceholderIndexes.indexOf(itemIndex);\r\n\r\n\t\t\t\t// remove placeholder if exists\r\n\t\t\t\t/* istanbul ignore if */\r\n\t\t\t\tif (placeholderPos !== -1 && typeof this._itemIndexToElementMap[itemIndex] !== 'undefined') {\r\n\t\t\t\t\tplaceholderElement = this._itemIndexToElementMap[itemIndex];\r\n\r\n\t\t\t\t\tthis._renderer.destroyItem(placeholderElement);\r\n\r\n\t\t\t\t\tthis._removeItemIndexToElement(itemIndex);\r\n\t\t\t\t\tthis._renderedPlaceholderIndexes.splice(placeholderPos, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._insertRenderedElement($elementWrapElement, elements[i], itemIndex);\r\n\r\n\t\t\t\tthis._renderedItemIndexes.push(itemIndex);\r\n\t\t\t} else {\r\n\t\t\t\t// only add placeholders if they don't already exist\r\n\t\t\t\tif (this._renderedPlaceholderIndexes.indexOf(itemIndex) === -1) {\r\n\t\t\t\t\tthis._insertRenderedElement($elementWrapElement, elements[i], itemIndex, true);\r\n\r\n\t\t\t\t\tthis._renderedPlaceholderIndexes.push(itemIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// the elements are first added to a fragment and then the whole fragment appended to scroller for performance\r\n\t\tif (useFragment) {\r\n\t\t\t$(this._scrollerWrap).append($elementRangeFragment);\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Inserts a rendered dom element into the carousel dom structure.\r\n\t *\r\n\t * @method _insertRenderedElement\r\n\t * @param {DOMElement} $wrap Wrap to append the element to once ready\r\n\t * @param {DOMElement} element Element to insert\r\n\t * @param {number} index Element index\r\n\t * @param {boolean} isPlaceholder Is the element a placeholder\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._insertRenderedElement = function($wrap, element, index, isPlaceholder) {\r\n\t\t// calculate the properties of the element\r\n\t\tvar $element = $(element),\r\n\t\t\torientation = this._config.orientation,\r\n\t\t\tsizeMode = this._config.sizeMode,\r\n\t\t\twrapSize = this._getMainWrapSize(),\r\n\t\t\twrapOppositeSize = this._getMainWrapOppositeSize(),\r\n\t\t\titemsPerPage = this._config.getItemsPerPage(wrapSize),\r\n\t\t\titemSize = this._calculateItemSize(wrapSize, itemsPerPage),\r\n\t\t\titemMargin = this._config.margin,\r\n\t\t\tgapPerItem = (itemMargin * (itemsPerPage - 1) / itemsPerPage),\r\n\t\t\teffectiveSize = Math.ceil(itemSize - gapPerItem),\r\n\t\t\teffectiveOffset = Math.floor(index * itemSize + index * (itemMargin - gapPerItem)),\r\n\t\t\t$wrapper = $('<div></div>'),\r\n\t\t\tcssProperties = {},\r\n\t\t\t$itemWrapper;\r\n\r\n\t\t// make sure the wrap has size if wrap size matching is used\r\n\t\t/* istanbul ignore if */\r\n\t\tif (sizeMode == Config.SizeMode.MATCH_WRAP && wrapOppositeSize === 0 && this._initiated) {\r\n\t\t\tthrow new Error('The wrap opposite size was calculated to be zero, this should not happen');\r\n\t\t}\r\n\r\n\t\t// the properties to set depends on the orientation\r\n\t\tif (orientation === Config.Orientation.HORIZONTAL) {\r\n\t\t\tcssProperties.width = effectiveSize;\r\n\t\t\tcssProperties.left = effectiveOffset;\r\n\r\n\t\t\tif (sizeMode == Config.SizeMode.MATCH_WRAP) {\r\n\t\t\t\tcssProperties.height = wrapOppositeSize;\r\n\t\t\t}\r\n\t\t} else if (orientation === Config.Orientation.VERTICAL) {\r\n\t\t\tcssProperties.height = effectiveSize;\r\n\t\t\tcssProperties.top = effectiveOffset;\r\n\r\n\t\t\tif (sizeMode == Config.SizeMode.MATCH_WRAP) {\r\n\t\t\t\tcssProperties.width = wrapOppositeSize;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// the element may be display: none to begin with, make it visible\r\n\t\t// TODO consider using a class instead\r\n\t\t$element.css('display', 'block');\r\n\r\n\t\t// wrap the item element in a carousel wrapper\r\n\t\t$itemWrapper = $element.wrap($wrapper).parent();\r\n\r\n\t\t// apply the css styles and add carousel item class\r\n\t\t$itemWrapper.css(cssProperties);\r\n\t\t$itemWrapper.addClass(this._config.getClassName('item'));\r\n\r\n\t\t// add the placeholder class as well if the element is a placeholder\r\n\t\tif (isPlaceholder) {\r\n\t\t\t$itemWrapper.addClass(this._config.getClassName('placeholder'));\r\n\t\t}\r\n\r\n\t\t// apply some pre-processing to each element about to be inserted into the dom\r\n\t\tthis._preprocessItemElement($itemWrapper, index);\r\n\r\n\t\t// append the element to the scroller wrap\r\n\t\t$wrap.append($itemWrapper);\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (typeof this._itemIndexToElementMap[index] !== 'undefined') {\r\n\t\t\tthrow new Error('Element at index #' + index + ' already exists, this should not happen');\r\n\t\t}\r\n\r\n\t\t// add the wrapped element to the index to element map\r\n\t\tthis._mapItemIndexToElement(index, $itemWrapper[0]);\r\n\t};\r\n\r\n\t/**\r\n\t * Adds a mapping between item index and its wrapper element.\r\n\t *\r\n\t * @method _mapItemIndexToElement\r\n\t * @param {number} index Item index\r\n\t * @param {DOMElement} element The DOM element\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._mapItemIndexToElement = function(index, element) {\r\n\t\tthis._itemIndexToElementMap[index] = element;\r\n\t};\r\n\r\n\t/**\r\n\t * Removes mapping between item index and its wrapper element.\r\n\t *\r\n\t * @method _removeItemIndexToElement\r\n\t * @param {number} index Item index to remove mapping for\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._removeItemIndexToElement = function(index) {\r\n\t\tdelete this._itemIndexToElementMap[index];\r\n\t};\r\n\r\n\t/**\r\n\t * Preprocesses the item wrapper element about to be inserted into the DOM.\r\n\t *\r\n\t * @method _preprocessCarouselItemElement\r\n\t * @param {jQuery} $itemWrapper The item wrapper element jQuery reference\r\n\t * @param {number} index Item index\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._preprocessItemElement = function($itemWrapper, index) {\r\n\t\tvar self = this;\r\n\t\t\t//itemHoverClass = this._config.getClassName('itemHover');\r\n\r\n\t\t// store the item index in wrapper element data\r\n\t\t$itemWrapper.data(this._config.cssPrefix + 'index', index);\r\n\r\n\t\t// listen for hover and out events to store the currently hovered item\r\n\t\t$itemWrapper.hover(\r\n\t\t\tfunction() {\r\n\t\t\t\tvar elementIndex = $(this).data(self._config.cssPrefix + 'index');\r\n\r\n\t\t\t\t// TODO not sure if it's a good idea\r\n\t\t\t\t//$(this).addClass(itemHoverClass);\r\n\r\n\t\t\t\tself._hoverItemIndex = elementIndex;\r\n\t\t\t},\r\n\t\t\tfunction() {\r\n\t\t\t\t//$(this).removeClass(itemHoverClass);\r\n\r\n\t\t\t\tself._hoverItemIndex = null;\r\n\t\t\t}\r\n\t\t);\r\n\t};\r\n\r\n\t/**\r\n\t * Makes sure that the scroller size matches the largest currently visible item size.\r\n\t *\r\n\t * This is executed only when using Config.SizeMode.MATCH_LARGEST_ITEM size mode.\r\n\t *\r\n\t * @method validateSize\r\n\t * @return {boolean} Was new positive size found\r\n\t */\r\n\tFlowCarousel.prototype.validateSize = function() {\r\n\t\t// only perform this routine if matching the largest item size\r\n\t\tif (this._config.sizeMode !== Config.SizeMode.MATCH_LARGEST_ITEM) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar oppositeOrientation = this._getOppositeOrientation(this._config.orientation),\r\n\t\t\tsizeProp = this._config.orientation === Config.Orientation.HORIZONTAL\r\n\t\t\t\t? 'height'\r\n\t\t\t\t: 'width',\r\n\t\t\tvisibleItems = this.getCurrentPageVisibleItemElements(),\r\n\t\t\tlargestChildSize = this._getLargestElementSize(\r\n\t\t\t\tvisibleItems,\r\n\t\t\t\toppositeOrientation,\r\n\t\t\t\tFlowCarousel.SizeMode.OUTER\r\n\t\t\t);\r\n\r\n\t\t// set the scroller to largest child size if it was possible to determine\r\n\t\tif (largestChildSize > 0 && largestChildSize !== this._lastLargestChildSize) {\r\n\t\t\t$(this._scrollerWrap).css(sizeProp, Math.ceil(largestChildSize) + 'px');\r\n\r\n\t\t\tthis._lastLargestChildSize = largestChildSize;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Re-initializes the layout.\r\n\t *\r\n\t * Used to apply responsive layout when the wrap size changes.\r\n\t *\r\n\t * Since fetching and rendering items can be asynchronous, this method returns a promise.\r\n\t *\r\n\t * @method _reLayout\r\n\t * @return {Deferred.Promise}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._reLayout = function() {\r\n\t\tvar focusItemIndex,\r\n\t\t\tpromise;\r\n\r\n\t\t// focus to last center item index if requested so by the configuration\r\n\t\tif (this._config.centerStartItemIndex) {\r\n\t\t\tfocusItemIndex = this._lastCenterItemIndex;\r\n\t\t} else {\r\n\t\t\tfocusItemIndex = this._currentItemIndex;\r\n\t\t}\r\n\r\n\t\t// reset current state\r\n\t\tthis._reset();\r\n\r\n\t\t// recalculate the layout navigating instantly to the last item\r\n\t\tthis._setupLayout(focusItemIndex, false, this._config.centerStartItemIndex);\r\n\r\n\t\t// render the items that may have become visible after the layout procedure\r\n\t\tpromise = this._validateItemsToRender();\r\n\r\n\t\t// update scroller size\r\n\t\tpromise.done(function() {\r\n\t\t\tthis.validateSize();\r\n\t\t}.bind(this));\r\n\r\n\t\treturn promise;\r\n\t};\r\n\r\n\t/**\r\n\t * Resets the component state and removes all rendered items.\r\n\t *\r\n\t * @method _reset\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._reset = function() {\r\n\t\tvar $scrollerWrap = $(this._scrollerWrap);\r\n\r\n\t\t$scrollerWrap\r\n\t\t\t.empty()\r\n\t\t\t.attr('style', null)\r\n\t\t\t.data(this._config.cssPrefix + 'last-size', null);\r\n\r\n\t\tthis._itemIndexToElementMap = {};\r\n\t\tthis._isAnimating = false;\r\n\t\tthis._targetItemIndex = 0;\r\n\t\tthis._currentItemIndex = 0;\r\n\t\tthis._lastCenterItemIndex = null;\r\n\t\tthis._lastLargestChildSize = null;\r\n\t\tthis._renderedItemIndexes = [];\r\n\t\tthis._renderedPlaceholderIndexes = [];\r\n\t\tthis._itemIndexToElementMap = {};\r\n\t\tthis._cache = Util.cloneObj(this._emptyCache);\r\n\t};\r\n\r\n\t/**\r\n\t * Sets up main wrap size change listener to apply responsive layout.\r\n\t *\r\n\t * @method _setupWindowResizeListener\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._setupWindowResizeListener = function() {\r\n\t\t// also validate on window resize\r\n\t\t$(window).on('resize', this._eventListeners.onWindowResize);\r\n\t};\r\n\r\n\t/**\r\n\t * Called on window resize event.\r\n\t *\r\n\t * @method _onWindowResize\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._onWindowResize = function() {\r\n\t\tif (!this._initiated) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._validateResponsiveLayout();\r\n\t};\r\n\r\n\t/**\r\n\t * Checks whether the carousel wrap size has changed and triggers re-layout if so.\r\n\t *\r\n\t * @method _validateResponsiveLayout\r\n\t * @param {boolean} force Force the validation even if busy\r\n\t * @return {boolean} Was re-layout scheduled\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._validateResponsiveLayout = function(force) {\r\n\t\t// don't perform the validation while animating\r\n\t\tif (this._isAnimating && force !== true) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar $element = $(this._mainWrap),\r\n\t\t\tlastSize = $element.data(this._config.cssPrefix + 'last-size') || null,\r\n\t\t\tcurrentSize = this._getMainWrapSize(true);\r\n\r\n\t\t$element.data(this._config.cssPrefix + 'last-size', currentSize);\r\n\r\n\t\t// perform the layout routine if the wrap size has changed and it did not change to zero\r\n\t\tif (lastSize === null || (currentSize !== lastSize && currentSize !== 0)) {\r\n\t\t\t// perform the re-layout routine only when the wrap size has not changed for some time\r\n\t\t\tthis._performDelayed('re-layout', function() {\r\n\t\t\t\tthis._reLayout();\r\n\t\t\t}.bind(this), this._config.responsiveLayoutDelay);\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\t/**\r\n\t * Visually notifies the user that carousel limit has been reached.\r\n\t *\r\n\t * @method _showLimit\r\n\t * @param {number} itemIndex Current item index\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._showLimit = function(itemIndex) {\r\n\t\tvar deferred = new Deferred(),\r\n\t\t\tlimitPixels = 30,\r\n\t\t\tlimitItemPosition,\r\n\t\t\tlimitDir,\r\n\t\t\tlimitMovePosition;\r\n\r\n\t\tif (this._isAnimating) {\r\n\t\t\tdeferred.resolve();\r\n\t\t} else {\r\n\t\t\tif (itemIndex === 0) {\r\n\t\t\t\tlimitDir = -1;\r\n\t\t\t} else {\r\n\t\t\t\tlimitDir = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlimitItemPosition = this.getItemPositionByIndex(itemIndex);\r\n\t\t\tlimitMovePosition = limitDir === -1\r\n\t\t\t\t? limitItemPosition + limitPixels\r\n\t\t\t\t: limitItemPosition - limitPixels;\r\n\r\n\t\t\tthis._isAnimating = true;\r\n\r\n\t\t\tthis._animator.animateToPosition(limitMovePosition).done(function () {\r\n\t\t\t\tthis._animator.animateToPosition(limitItemPosition).done(function () {\r\n\t\t\t\t\tthis._isAnimating = false;\r\n\r\n\t\t\t\t\tdeferred.resolve();\r\n\t\t\t\t}.bind(this));\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\r\n\t\treturn deferred.promise();\r\n\t};\r\n\r\n\t/**\r\n\t * Calculates and returns a single item size based on wrap size and items per page.\r\n\t *\r\n\t * @method _calculateItemSize\r\n\t * @param {number} wrapSize Wrapping element size\r\n\t * @param {number} itemsPerPage Number of items per page\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._calculateItemSize = function(wrapSize, itemsPerPage) {\r\n\t\treturn wrapSize / itemsPerPage;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the size of an element.\r\n\t *\r\n\t * Horizontal orientation returns element width and vertical height.\r\n\t *\r\n\t * Mode sets whether to return the inner or outer width/height (defaults to inner).\r\n\t *\r\n\t * @method _getElementSize\r\n\t * @param {DOMelement} element Element to get size of\r\n\t * @param {Config/Orientation:property} orientation Orientation to get size of\r\n\t * @param {FlowCarousel.SizeMode:property} [mode=FlowCarousel.SizeMode.INNER] Size mode\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._getElementSize = function(element, orientation, mode) {\r\n\t\tmode = mode || FlowCarousel.SizeMode.INNER;\r\n\r\n\t\tvar methods = mode === FlowCarousel.SizeMode.INNER\r\n\t\t\t? ['innerWidth', 'innerHeight']\r\n\t\t\t: ['outerWidth', 'outerHeight'];\r\n\r\n\t\tif (orientation === Config.Orientation.HORIZONTAL) {\r\n\t\t\treturn $(element)[methods[0]]();\r\n\t\t} else if (orientation === Config.Orientation.VERTICAL) {\r\n\t\t\treturn $(element)[methods[1]]();\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid orientation \"' + orientation + '\" requested');\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns biggest element size of given elements given orientation and size mode.\r\n\t *\r\n\t * Horizontal orientation returns element width and vertical height.\r\n\t *\r\n\t * Mode sets whether to return the inner or outer width/height (defaults to inner).\r\n\t *\r\n\t * @method _getLargestElementSize\r\n\t * @param {DOMElement[]} elements Array of elements\r\n\t * @param {Config/Orientation:property} orientation Orientation to get size of\r\n\t * @param {FlowCarousel.SizeMode:property} [mode=FlowCarousel.SizeMode.INNER] Size mode\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._getLargestElementSize = function(elements, orientation, mode) {\r\n\t\tvar biggestSize = 0,\r\n\t\t\tchildren,\r\n\t\t\tinspectElement,\r\n\t\t\telementSize;\r\n\r\n\t\t$(elements).each(function(index, element) {\r\n\t\t\tchildren = $(element).children();\r\n\r\n\t\t\t// use the first child for reference if possible\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (children.length > 0) {\r\n\t\t\t\tinspectElement = children[0];\r\n\t\t\t} else {\r\n\t\t\t\tinspectElement = element;\r\n\t\t\t}\r\n\r\n\t\t\telementSize = this._getElementSize(inspectElement, orientation, mode);\r\n\r\n\t\t\tif (elementSize > biggestSize) {\r\n\t\t\t\tbiggestSize = elementSize;\r\n\t\t\t}\r\n\t\t}.bind(this));\r\n\r\n\t\treturn biggestSize;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the main wrap size in the main orientation.\r\n\t *\r\n\t * Uses cached value if available.\r\n\t *\r\n\t * @method _getMainWrapSize\r\n\t * @param {boolean} [ignoreCache=false] Should cache be ignored\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype._getMainWrapSize = function(ignoreCache) {\r\n\t\tif (this._useCache && this._cache.wrapSize !== null && ignoreCache !== true) {\r\n\t\t\treturn this._cache.wrapSize;\r\n\t\t}\r\n\r\n\t\tvar orientation = this._config.orientation;\r\n\r\n\t\tthis._cache.wrapSize = this._getElementSize(this._mainWrap, orientation);\r\n\r\n\t\t$(this._mainWrap).data(this._config.cssPrefix + 'last-size', this._cache.wrapSize);\r\n\r\n\t\treturn this._cache.wrapSize;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the main wrap size in the opposite orientation.\r\n\t *\r\n\t * Uses cached value if available.\r\n\t *\r\n\t * @method _getMainWrapOppositeSize\r\n\t * @param {boolean} [ignoreCache=false] Should cache be ignored\r\n\t * @return {number}\r\n\t */\r\n\tFlowCarousel.prototype._getMainWrapOppositeSize = function(ignoreCache) {\r\n\t\tif (this._useCache && this._cache.wrapOppositeSize !== null && ignoreCache !== true) {\r\n\t\t\treturn this._cache.wrapOppositeSize;\r\n\t\t}\r\n\r\n\t\tvar orientation = this._config.orientation,\r\n\t\t\toppositeOrientation = this._getOppositeOrientation(orientation);\r\n\r\n\t\tthis._cache.wrapOppositeSize = this._getElementSize(this._mainWrap, oppositeOrientation);\r\n\r\n\t\treturn this._cache.wrapOppositeSize;\r\n\t};\r\n\r\n\t/**\r\n\t * Returns the opposite orientation name.\r\n\t *\r\n\t * For Config.Orientation.HORIZONTAL returns Config.Orientation.VERTICAL and vice versa.\r\n\t *\r\n\t * @method _getOppositeOrientation\r\n\t * @param {Config/Orientation:property} orientation Orientation to get opposite of\r\n\t * @return {Config/Orientation:property}\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._getOppositeOrientation = function(orientation) {\r\n\t\treturn orientation === Config.Orientation.HORIZONTAL\r\n\t\t\t? Config.Orientation.VERTICAL\r\n\t\t\t: Config.Orientation.HORIZONTAL;\r\n\t};\r\n\r\n\t/**\r\n\t * This is called by drag-based navigators on drag begin event.\r\n\t *\r\n\t * @method _onDragBegin\r\n\t * @param {number} startPosition The start dragging position in the main orientation\r\n\t * @param {number} dragOppositePosition The start dragging position in the opposite orientation\r\n\t * @param {number} carouselPosition The start carousel position\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._onDragBegin = function(startPosition, dragOppositePosition, carouselPosition) {\r\n\t\tthis._dragging = true;\r\n\r\n\t\tthis.emit(FlowCarousel.Event.DRAG_BEGIN, startPosition, dragOppositePosition, carouselPosition);\r\n\t};\r\n\r\n\t/**\r\n\t * This is called by drag-based navigators on drag end event.\r\n\t *\r\n\t * @method _onDragEnd\r\n\t * @param {string} navigationMode Navigation mode, usually 'navigate-page' or 'navigate-item'\r\n\t * @param {number} startPosition Drag start position\r\n\t * @param {number} endPosition Drag end position\r\n\t * @param {number} deltaDragPosition Relative drag amount\r\n\t * @param {number} closestIndex Closest matching page or item index depending on navigation mode\r\n\t * @param {number} direction Drag direction, either -1 or 1\r\n\t * @param {DOMElement} targetElement The element that the drag ended on\r\n\t * @private\r\n\t */\r\n\tFlowCarousel.prototype._onDragEnd = function(\r\n\t\tnavigationMode,\r\n\t\tstartPosition,\r\n\t\tendPosition,\r\n\t\tdeltaDragPosition,\r\n\t\tclosestIndex,\r\n\t\tdirection,\r\n\t\ttargetElement\r\n\t) {\r\n\t\tthis._dragging = false;\r\n\r\n\t\tthis.emit(\r\n\t\t\tFlowCarousel.Event.DRAG_END,\r\n\t\t\tnavigationMode,\r\n\t\t\tstartPosition,\r\n\t\t\tendPosition,\r\n\t\t\tclosestIndex,\r\n\t\t\tdeltaDragPosition,\r\n\t\t\tdirection,\r\n\t\t\ttargetElement\r\n\t\t);\r\n\t};\r\n\r\n\t/**\r\n\t * Performs some action delayed by given amount.\r\n\t *\r\n\t * If the method is called several times with the same name, the action is executed only once after the time\r\n\t * has passed from the last call.\r\n\t *\r\n\t * @method performDelayed\r\n\t * @param {String} name Name of the action\r\n\t * @param {Function} callback Callback to call\r\n\t * @param {Number} [delay=1000] The delay, default to 1000 ms\r\n\t */\r\n\tFlowCarousel.prototype._performDelayed = function(name, callback, delay) {\r\n\t\tdelay = delay || 1000;\r\n\r\n\t\tif (typeof this._delayedTasks[name] !== 'undefined' && this._delayedTasks[name] !== null) {\r\n\t\t\twindow.clearTimeout(this._delayedTasks[name]);\r\n\r\n\t\t\tthis._delayedTasks[name] = null;\r\n\t\t}\r\n\r\n\t\tthis._delayedTasks[name] = window.setTimeout(function() {\r\n\t\t\tthis._delayedTasks[name] = null;\r\n\r\n\t\t\tcallback.apply(callback, [name, delay]);\r\n\t\t}.bind(this), delay);\r\n\t};\r\n\r\n\t// use the Exporter to export it to AMD, Angular etc\r\n\tExporter.export(FlowCarousel);\r\n\r\n\treturn FlowCarousel;\r\n});\n"]}